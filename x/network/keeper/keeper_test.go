package keeper_test

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconn"

	//nolint

	"github.com/ethereum/go-ethereum/common"

	sdkmath "cosmossdk.io/math"
	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519"
	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	"github.com/cosmos/cosmos-sdk/server"
	sdkconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/cosmos/go-bip39"

	abci "github.com/cometbft/cometbft/abci/types"
	"github.com/cometbft/cometbft/crypto"
	"github.com/cometbft/cometbft/crypto/tmhash"
	"github.com/cometbft/cometbft/node"
	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
	tmprotoversion "github.com/cometbft/cometbft/proto/tendermint/version"
	tmversion "github.com/cometbft/cometbft/proto/tendermint/version"
	cmttypes "github.com/cometbft/cometbft/types"
	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/cometbft/cometbft/version"
	cmtversion "github.com/cometbft/cometbft/version"

	clienttypes "github.com/cosmos/ibc-go/v8/modules/core/02-client/types"
	ibctm "github.com/cosmos/ibc-go/v8/modules/light-clients/07-tendermint"
	ibcgotesting "github.com/cosmos/ibc-go/v8/testing"
	"github.com/cosmos/ibc-go/v8/testing/mock"

	app "mythos/v1/app"
	"mythos/v1/server/config"
	ibctesting "mythos/v1/testutil/ibc"
	"mythos/v1/x/network/keeper"
	"mythos/v1/x/network/types"
	wasmxkeeper "mythos/v1/x/wasmx/keeper"
	"mythos/v1/x/wasmx/keeper/testutil"
	wasmxtypes "mythos/v1/x/wasmx/types"

	networkkeeper "mythos/v1/x/network/keeper"
	networkconfig "mythos/v1/x/network/server/config"
)

// KeeperTestSuite is a testing suite to test keeper functions
type KeeperTestSuite struct {
	suite.Suite
	chain TestChain
}

type TestChain struct {
	T       *testing.T
	ChainId string
	ctx     sdk.Context

	App *app.App
	// queryClient types.QueryClient
	// signer      keyring.Signer
	consAddress sdk.ConsAddress
	// validator   stakingtypes.Validator
	Denom           string
	Faucet          *wasmxkeeper.TestFaucet
	ProposerAddress []byte

	LastHeader    *ibctm.Header  // header for last block height committed
	CurrentHeader tmproto.Header // header for current block height
	TxConfig      client.TxConfig
	Codec         codec.Codec

	Vals     *tmtypes.ValidatorSet
	NextVals *tmtypes.ValidatorSet
	Signers  map[string]tmtypes.PrivValidator

	// autogenerated sender private key
	SenderPrivKey cryptotypes.PrivKey
	SenderAccount sdk.AccountI
}

var s *KeeperTestSuite

// GetContext returns the current context for the application.
func (chain *TestChain) GetContext() sdk.Context {
	return chain.App.GetBaseApp().NewUncachedContext(false, chain.CurrentHeader)
}

// TestKeeperTestSuite runs all the tests within this package.
func TestKeeperTestSuite(t *testing.T) {
	s = new(KeeperTestSuite)
	suite.Run(t, s)

	// Run Ginkgo integration tests
	RegisterFailHandler(Fail)
	RunSpecs(t, "Keeper Suite")
}

func (suite *KeeperTestSuite) GetApp(chain *ibcgotesting.TestChain) *app.App {
	return suite.chain.App
}

func (suite *KeeperTestSuite) App() *app.App {
	return suite.chain.App
}

func (suite *KeeperTestSuite) GetAppContext(chain *ibcgotesting.TestChain) testutil.AppContext {
	appContext := testutil.AppContext{
		S:             suite,
		App:           suite.App(),
		Chain:         chain,
		FinalizeBlock: suite.FinalizeBlock,
	}
	encodingConfig := app.MakeEncodingConfig()
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(chain.ChainID)
	appContext.Denom = app.BaseDenom

	t := suite.T()
	appContext.Faucet = wasmxkeeper.NewTestFaucet(t, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(appContext.Denom, sdkmath.NewInt(100_000_000_000)))

	return appContext
}

func (suite *KeeperTestSuite) AppContext() AppContext {
	appContext := AppContext{
		S:             suite,
		App:           suite.App(),
		Chain:         suite.chain,
		FinalizeBlock: suite.FinalizeBlock,
	}
	encodingConfig := app.MakeEncodingConfig()
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(suite.chain.ChainId)
	appContext.Denom = app.BaseDenom

	t := suite.T()
	appContext.Faucet = wasmxkeeper.NewTestFaucet(t, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(appContext.Denom, sdkmath.NewInt(100_000_000_000)))

	return appContext
}

// SetupTest creates a coordinator with 2 test chains.
func (suite *KeeperTestSuite) SetupTest() {
	suite.SetupApp()
}

func (suite *KeeperTestSuite) SetupApp() {
	t := suite.T()
	chainId := "mythos_7001-1"

	// generate validator private/public key
	privVal := mock.NewPV()
	pubKey, err := privVal.GetPubKey()
	require.NoError(t, err)

	// create validator set with single validator
	validator := tmtypes.NewValidator(pubKey, 1)
	valSet := tmtypes.NewValidatorSet([]*tmtypes.Validator{validator})
	signersByAddress := make(map[string]tmtypes.PrivValidator, 1)
	signersByAddress[pubKey.Address().String()] = privVal

	// generate genesis account
	senderPrivKey := secp256k1.GenPrivKey()
	acc := authtypes.NewBaseAccount(senderPrivKey.PubKey().Address().Bytes(), senderPrivKey.PubKey(), 0, 0)

	senderAddress := common.BytesToAddress(senderPrivKey.PubKey().Address().Bytes())

	amount := sdk.TokensFromConsensusPower(1, sdk.DefaultPowerReduction)

	balance := banktypes.Balance{
		Address: acc.GetAddress().String(),
		Coins:   sdk.NewCoins(sdk.NewCoin(app.BondDenom, amount)),
	}

	testApp, resInit := ibctesting.SetupWithGenesisValSet(t, valSet, []authtypes.GenesisAccount{acc}, chainId, 0, balance)

	consAddress := sdk.ConsAddress(senderPrivKey.PubKey().Address())

	// create current header and call begin block
	header := tmproto.Header{
		ChainID:         chainId,
		Height:          1,
		Time:            time.Now().UTC(),
		ProposerAddress: consAddress.Bytes(),
		Version: tmversion.Consensus{
			Block: version.BlockProtocol,
		},
		LastBlockId: tmproto.BlockID{
			Hash: tmhash.Sum([]byte("block_id")),
			PartSetHeader: tmproto.PartSetHeader{
				Total: 11,
				Hash:  tmhash.Sum([]byte("partset_header")),
			},
		},
		AppHash:            tmhash.Sum([]byte("app")),
		DataHash:           tmhash.Sum([]byte("data")),
		EvidenceHash:       tmhash.Sum([]byte("evidence")),
		ValidatorsHash:     tmhash.Sum([]byte("validators")),
		NextValidatorsHash: tmhash.Sum([]byte("next_validators")),
		ConsensusHash:      tmhash.Sum([]byte("consensus")),
		LastResultsHash:    tmhash.Sum([]byte("last_result")),
	}

	txConfig := testApp.GetTxConfig()

	mapp, ok := testApp.(*app.App)
	require.True(t, ok, "not app")
	chain := TestChain{
		T:             suite.T(),
		ChainId:       chainId,
		App:           mapp,
		CurrentHeader: header,
		TxConfig:      txConfig,
		Codec:         mapp.AppCodec(),
		Vals:          valSet,
		NextVals:      valSet,
		Signers:       signersByAddress,
		SenderPrivKey: senderPrivKey,
		SenderAccount: acc,
	}

	ctx := chain.GetContext()
	mapp.AccountKeeper.SetAccount(ctx, acc)

	valAddrCodec := txConfig.SigningContext().ValidatorAddressCodec()
	valAddr := sdk.ValAddress(senderAddress.Bytes())
	valStr, err := valAddrCodec.BytesToString(valAddr)
	require.NoError(t, err)
	_validator, err := stakingtypes.NewValidator(valStr, senderPrivKey.PubKey(), stakingtypes.Description{})
	require.NoError(t, err)
	_validator = stakingkeeper.TestingUpdateValidator(mapp.StakingKeeper, ctx, _validator, true)
	mapp.StakingKeeper.Hooks().AfterValidatorCreated(ctx, valAddr)

	err = mapp.StakingKeeper.SetValidatorByConsAddr(ctx, _validator)
	require.NoError(t, err)
	mapp.StakingKeeper.SetValidator(ctx, _validator)

	_, err = mapp.Commit()
	require.NoError(t, err)

	suite.chain = chain
	err = suite.InitConsensusContract(resInit, pubKey, privVal.PrivKey)
	require.NoError(t, err)
}

func (suite *KeeperTestSuite) InitConsensusContract(resInit *abci.ResponseInitChain, pubKey crypto.PubKey, privKey networkkeeper.PrivKey) error {
	res, err := suite.App().Info(networkkeeper.RequestInfo)
	if err != nil {
		return fmt.Errorf("error calling Info: %v", err)
	}
	vals, err := cmttypes.PB2TM.ValidatorUpdates(resInit.Validators)
	if err != nil {
		return err
	}
	consensusParams := cmttypes.ConsensusParamsFromProto(*app.DefaultTestingConsensusParams)
	if resInit.ConsensusParams != nil {
		consensusParams = consensusParams.Update(resInit.ConsensusParams)
	}

	cfgNetwork := networkconfig.DefaultNetworkConfigConfig()
	networkServer := networkkeeper.NewMsgServerImpl(suite.App().GetNetworkKeeper(), suite.App().BaseApp)
	err = networkkeeper.InitConsensusContract(
		suite.App(),
		suite.App().Logger(),
		*cfgNetwork,
		networkServer,
		resInit.AppHash,
		&consensusParams,
		vals,
		res.AppVersion,
		pubKey,
		privKey,
	)
	return err
}

func (suite *KeeperTestSuite) Commit()                                               {}
func (suite *KeeperTestSuite) CommitNBlocks(chain *ibcgotesting.TestChain, n uint64) {}
func (suite *KeeperTestSuite) Coordinator() *ibcgotesting.Coordinator {
	return nil
}
func (suite *KeeperTestSuite) CommitNBlocks_(chain TestChain, n uint64) {
	for i := 0; i < int(n); i++ {
		_, err := suite.CommitBlock()
		suite.Require().NoError(err)
	}
}

func (s *KeeperTestSuite) GetRandomAccount() simulation.Account {
	pk := ed25519.GenPrivKey()
	privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

func (s *KeeperTestSuite) GetAccountFromMnemonic(mnemonic string) simulation.Account {
	s.Require().True(bip39.IsMnemonicValid(mnemonic))
	hdPath := hd.CreateHDPath(118, 0, 0).String()
	derivedPriv, err := hd.Secp256k1.Derive()(mnemonic, "", hdPath)
	s.Require().NoError(err)
	privKey := hd.Secp256k1.Generate()(derivedPriv)

	// privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

const bufSize = 1024 * 1024

func GrpcSetup(t *testing.T, mapp *app.App) *bufconn.Listener {
	goctx := context.Background()
	serverCtx := server.NewDefaultContext()
	clientCtx := client.Context{}.WithTxConfig(mapp.TxConfig()).WithChainID(mapp.ChainID())
	config, err := config.GetConfig(serverCtx.Viper)
	require.NoError(t, err)

	lis := bufconn.Listen(bufSize)
	grpcServer, err := NewGRPCServer(goctx, serverCtx, clientCtx, &config, mapp, nil)
	require.NoError(t, err)

	go func() {
		if err := grpcServer.Serve(lis); err != nil {
			log.Fatalf("Server exited with error: %v", err)
		}
	}()
	return lis
}

func (suite *KeeperTestSuite) GrpcClient(ctx context.Context, target string, mapp *app.App) (types.MsgClient, *grpc.ClientConn) {
	t := suite.T()
	lis := GrpcSetup(t, mapp)
	bufDialer := func(context.Context, string) (net.Conn, error) {
		return lis.Dial()
	}
	// target := "bufnet"
	conn, err := grpc.DialContext(ctx, target, grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
	if err != nil {
		t.Fatalf("Failed to dial bufnet: %v", err)
	}
	return types.NewMsgClient(conn), conn
}

func NewGRPCServer(
	ctx context.Context,
	svrCtx *server.Context,
	clientCtx client.Context,
	cfg *config.Config,
	app servertypes.Application,
	tmNode *node.Node,
) (*grpc.Server, error) {
	grpccfg := cfg.GRPC
	maxSendMsgSize := grpccfg.MaxSendMsgSize
	if maxSendMsgSize == 0 {
		maxSendMsgSize = sdkconfig.DefaultGRPCMaxSendMsgSize
	}

	maxRecvMsgSize := grpccfg.MaxRecvMsgSize
	if maxRecvMsgSize == 0 {
		maxRecvMsgSize = sdkconfig.DefaultGRPCMaxRecvMsgSize
	}

	grpcSrv := grpc.NewServer(
		grpc.ForceServerCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
		grpc.MaxSendMsgSize(maxSendMsgSize),
		grpc.MaxRecvMsgSize(maxRecvMsgSize),
	)

	_, err := keeper.RegisterGRPCServer(ctx, svrCtx, clientCtx, cfg, app, grpcSrv)
	if err != nil {
		return nil, fmt.Errorf("failed to register grpc server: %w", err)
	}
	return grpcSrv, nil
}

func (suite *KeeperTestSuite) FinalizeBlock(txs [][]byte) (*abci.ResponseFinalizeBlock, error) {
	for _, tx := range txs {
		msg := []byte(fmt.Sprintf(`{"run":{"event":{"type":"newTransaction","params":[{"key":"transaction", "value":"%s"}]}}}`, base64.StdEncoding.EncodeToString(tx)))
		_, err := suite.chain.App.NetworkKeeper.ExecuteContract(suite.chain.GetContext(), &types.MsgExecuteContract{
			Sender:   "consensus",
			Contract: "consensus",
			Msg:      msg,
		})
		suite.Require().NoError(err)
	}
	return suite.CommitBlock()
}

func (suite *KeeperTestSuite) CommitBlock() (*abci.ResponseFinalizeBlock, error) {
	lastInterval := suite.GetLastInterval(suite.chain.GetContext())
	currentState := suite.GetCurrentState(suite.chain.GetContext())
	blockDelay := suite.GetBlockDelay(suite.chain.GetContext())

	// msg1 := []byte(`{"delay":"roundTimeout","state":"#Tendermint_0.initialized.prestart","intervalId":1}`)
	// msg1 := []byte(`{"delay":"heartbeatTimeout","state":"#RAFT-FULL-1.initialized.Leader.active","intervalId":2}`)
	msg1 := []byte(fmt.Sprintf(`{"delay":"%s","state":"%s","intervalId":%s}`, blockDelay, currentState, lastInterval))
	respbz, err := suite.chain.App.NetworkKeeper.ExecuteEventual(suite.chain.GetContext(), &types.MsgExecuteContract{
		Sender:   "consensus",
		Contract: "consensus",
		Msg:      msg1,
	})
	suite.Require().NoError(err)
	log.Printf("* FinalizeBlock END: %+v", string(respbz.Data))

	lastBlock := suite.App().LastBlockHeight()
	log.Printf("-lastBlock: %+v", lastBlock)
	return suite.GetBlock(suite.chain.GetContext(), lastBlock)
}

func (suite *KeeperTestSuite) GetBlockDelay(ctx sdk.Context) string {
	return suite.GetContextValue(ctx, types.BLOCK_DELAY, wasmxtypes.ROLE_CONSENSUS)
}

func (suite *KeeperTestSuite) GetCurrentState(ctx sdk.Context) string {
	msg := []byte(`{"getCurrentState":{}}`)
	resp, err := suite.chain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetContextValue(ctx sdk.Context, key string, addr string) string {
	msg := []byte(fmt.Sprintf(`{"getContextValue":{"key":"%s"}}`, key))
	resp, err := suite.chain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   addr,
		Contract: addr,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetLastInterval(ctx sdk.Context) string {
	key := types.GetLastIntervalIdKey()
	return suite.GetContextValue(ctx, key, wasmxtypes.ROLE_CONSENSUS)
}

func (suite *KeeperTestSuite) GetBlock(ctx sdk.Context, height int64) (*abci.ResponseFinalizeBlock, error) {
	key := types.GetBlockKey(height)
	data := suite.GetContextValue(ctx, key, wasmxtypes.ROLE_STORAGE)
	if len(data) == 0 {
		return nil, fmt.Errorf("tx block (%d) not found", height)
	}
	var entry types.BlockEntry
	err := json.Unmarshal([]byte(data), &entry)
	if err != nil {
		return nil, err
	}
	var blockResultData abci.ResponseFinalizeBlock
	err = json.Unmarshal(entry.Result, &blockResultData)
	if err != nil {
		return nil, err
	}
	return &blockResultData, nil
}

func (suite *KeeperTestSuite) commitBlock(res *abci.ResponseFinalizeBlock) {
	_, err := suite.chain.App.Commit()
	require.NoError(suite.T(), err)

	// set the last header to the current header
	// use nil trusted fields
	suite.chain.LastHeader = suite.chain.CurrentTMClientHeader()

	// val set changes returned from previous block get applied to the next validators
	// of this block. See tendermint spec for details.
	suite.chain.Vals = suite.chain.NextVals
	suite.chain.NextVals = ibcgotesting.ApplyValSetChanges(suite.T(), suite.chain.Vals, res.ValidatorUpdates)

	// increment the current header
	suite.chain.CurrentHeader = tmproto.Header{
		ChainID: suite.chain.ChainId,
		Height:  suite.chain.App.LastBlockHeight() + 1,
		AppHash: suite.chain.App.LastCommitID().Hash,
		// NOTE: the time is increased by the coordinator to maintain time synchrony amongst
		// chains.
		Time:               suite.chain.CurrentHeader.Time,
		ValidatorsHash:     suite.chain.Vals.Hash(),
		NextValidatorsHash: suite.chain.NextVals.Hash(),
		ProposerAddress:    suite.chain.CurrentHeader.ProposerAddress,
	}
}

// CreateTMClientHeader creates a TM header to update the TM client. Args are passed in to allow
// caller flexibility to use params that differ from the chain.
func (chain *TestChain) CreateTMClientHeader(chainID string, blockHeight int64, trustedHeight clienttypes.Height, timestamp time.Time, cmtValSet, nextVals, tmTrustedVals *cmttypes.ValidatorSet, signers map[string]cmttypes.PrivValidator) *ibctm.Header {
	var (
		valSet      *tmproto.ValidatorSet
		trustedVals *tmproto.ValidatorSet
	)
	require.NotNil(chain.T, cmtValSet)

	tmHeader := cmttypes.Header{
		Version:            tmprotoversion.Consensus{Block: cmtversion.BlockProtocol, App: 2},
		ChainID:            chainID,
		Height:             blockHeight,
		Time:               timestamp,
		LastBlockID:        MakeBlockID(make([]byte, tmhash.Size), 10_000, make([]byte, tmhash.Size)),
		LastCommitHash:     chain.App.LastCommitID().Hash,
		DataHash:           tmhash.Sum([]byte("data_hash")),
		ValidatorsHash:     cmtValSet.Hash(),
		NextValidatorsHash: nextVals.Hash(),
		ConsensusHash:      tmhash.Sum([]byte("consensus_hash")),
		AppHash:            chain.CurrentHeader.AppHash,
		LastResultsHash:    tmhash.Sum([]byte("last_results_hash")),
		EvidenceHash:       tmhash.Sum([]byte("evidence_hash")),
		ProposerAddress:    cmtValSet.Proposer.Address, //nolint:staticcheck
	}

	hhash := tmHeader.Hash()
	blockID := MakeBlockID(hhash, 3, tmhash.Sum([]byte("part_set")))
	voteSet := cmttypes.NewVoteSet(chainID, blockHeight, 1, tmproto.PrecommitType, cmtValSet)

	// MakeCommit expects a signer array in the same order as the validator array.
	// Thus we iterate over the ordered validator set and construct a signer array
	// from the signer map in the same order.
	var signerArr []cmttypes.PrivValidator   //nolint:prealloc // using prealloc here would be needlessly complex
	for _, v := range cmtValSet.Validators { //nolint:staticcheck // need to check for nil validator set
		signerArr = append(signerArr, signers[v.Address.String()])
	}

	extCommit, err := cmttypes.MakeExtCommit(blockID, blockHeight, 1, voteSet, signerArr, timestamp, false)
	require.NoError(chain.T, err)

	signedHeader := &tmproto.SignedHeader{
		Header: tmHeader.ToProto(),
		Commit: extCommit.ToCommit().ToProto(),
	}

	if cmtValSet != nil { //nolint:staticcheck
		valSet, err = cmtValSet.ToProto()
		require.NoError(chain.T, err)
	}

	if tmTrustedVals != nil {
		trustedVals, err = tmTrustedVals.ToProto()
		require.NoError(chain.T, err)
	}

	// The trusted fields may be nil. They may be filled before relaying messages to a client.
	// The relayer is responsible for querying client and injecting appropriate trusted fields.
	return &ibctm.Header{
		SignedHeader:      signedHeader,
		ValidatorSet:      valSet,
		TrustedHeight:     trustedHeight,
		TrustedValidators: trustedVals,
	}
}

func (chain *TestChain) CurrentTMClientHeader() *ibctm.Header {
	return chain.CreateTMClientHeader(
		chain.ChainId,
		chain.CurrentHeader.Height,
		clienttypes.Height{},
		chain.CurrentHeader.Time,
		chain.Vals,
		chain.NextVals,
		nil,
		chain.Signers,
	)
}

// MakeBlockID copied unimported test functions from cmttypes to use them here
func MakeBlockID(hash []byte, partSetSize uint32, partSetHash []byte) cmttypes.BlockID {
	return cmttypes.BlockID{
		Hash: hash,
		PartSetHeader: cmttypes.PartSetHeader{
			Total: partSetSize,
			Hash:  partSetHash,
		},
	}
}
