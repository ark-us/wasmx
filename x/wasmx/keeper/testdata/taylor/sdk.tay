(import "json")
(def! store-string (fn* (key value)
    (wasmx-storageStore (string.encode key) (string.encode value))
))
(def! load-string-bz (fn* (key)
    (wasmx-storageLoad (string.encode key))
))
(def! load-string (fn* (key) (string.decode (load-string-bz key))))
(def! store-u256 (fn* (keybz value)
    (wasmx-storageStore keybz (u256.encode value))
))
(def! load-u256 (fn* (keybz) (let* (
        valuebz (wasmx-storageLoad keybz)
    )
        (if (> (buffer.length valuebz) 0)
            (u256.decode valuebz)
            u[0 0 0 0]
        )
)))
(def! revert (fn* (msgstr)
    (wasmx-revert (string-encode msgstr))
))
(def! log-log (fn* (msgstr)
    (console.log (string-encode msgstr))
))
(def! log-info (fn* (msgstr)
    (console.info (string-encode msgstr))
))
(def! log-debug (fn* (msgstr)
    (console.debug (string-encode msgstr))
))
(def! log-error (fn* (msgstr)
    (console.error (string-encode msgstr))
))
(def! logger-info (fn* (msgstr parts)
    (wasmx-LoggerInfo (string.encode (json-stringify {"msg" msgstr "parts" parts})))
))
(def! logger-error (fn* (msgstr parts)
    (wasmx-LoggerError (string.encode (json-stringify {"msg" msgstr "parts" parts})))
))
(def! logger-debug (fn* (msgstr parts)
    (wasmx-LoggerDebug (string.encode (json-stringify {"msg" msgstr "parts" parts})))
))

(def! addr-humanize (fn* (addrbz)
    (string.decode (wasmx-addr_humanize addrbz))
))
(def! addr-canonicalize (fn* (addrstr)
    (wasmx-addr_canonicalize (string.encode addrstr))
))
(def! addr-equivalent (fn* (addrstr1 addrstr2)
    (wasmx-addr_equivalent (string.encode addrstr1) (string.encode addrstr2))
))
(def! addr-humanize-mc (fn* (addrbz prefixstr)
    (string.decode (wasmx-addr_humanize_mc addrbz (string.encode prefixstr)))
))
(def! addr-canonicalize-mc (fn* (addrstr)
    (json-parse (string.decode (wasmx-addr_canonicalize_mc (string.encode addrstr))))
))
(def! get-caller (fn* ()
    (addr-humanize (wasmx-getCaller))
))
(def! get-address (fn* ()
    (addr-humanize (wasmx-getAddress))
))
(def! get-calldata (fn* ()
    (string.decode (wasmx-getCallData))
))
(def! get-chainId (fn* ()
    (string.decode (wasmx-getChainId))
))
;; returns a list of buffer objects
(def! storageLoadRange (fn* (startkeybz endkeybz reverse)
    (map (fn* (v) (base64.decode v))
        (json-parse (string.decode (wasmx-storageLoadRange (string.encode (json-stringify {"start_key" startkeybz "end_key" endkeybz "reverse" reverse})))))
    )
))

(def! storageLoadRangePairs (fn* (startkeybz endkeybz reverse) (let* (
    buf (wasmx-storageLoadRangePairs (string.encode (json-stringify {"start_key" startkeybz "end_key" endkeybz "reverse" reverse})))
    resp (json-parse (string.decode buf))
    values
)
    (get resp "values") ;; StoragePair[] {key,value}
)))

(def! wasmxlog (fn* (typestr databuf topicsbufarr)
    (wasmx-log (string.encode (json-stringify {
        "type" typestr
        "data" databuf
        "topics" topicsbufarr
    })))
))

(def! getBlockHash (fn* (index)
    (wasmx-getBlockHash (u256.encode index))
))

(def! get-address-by-role (fn* (rolestr) (addr-humanize (wasmx-getAddressByRole (string.encode rolestr)))))

(def! get-role-by-address (fn* (addrstr)
    (string.decode (wasmx-getRoleByAddress (addr-canonicalize addrstr)))
))

;; roles
(def! ROLE_BANK "bank")
(def! ROLE_AUTH "auth")

;; utils

(def! call-contract (fn* (req) (let* (
    ;; base64 encode calldata
    req (assoc req "calldata" (base64.encode (string.encode (get req "calldata"))))
    ;; set defaults if fields not present
    req (if (contains? req "value") req (assoc req "value" (u256.from_hex "0x0000000000000000000000000000000000000000000000000000000000000000")))
    req (if (contains? req "gasLimit") req (assoc req "gasLimit" 2000000))
    req (if (contains? req "isQuery") req (assoc req "isQuery" true))
    reqstr (json-stringify {
        "to" (get req "to")
        "calldata" (get req "calldata")
        "isQuery" (get req "isQuery")
        "value" (u256.to_hex (get req "value"))
        "gasLimit" (get req "gasLimit")
    })
    resp (wasmx-call (string.encode reqstr))
    decoded (json-parse (string.decode resp))
    success (get decoded "success")
    data (string.decode (base64.decode (get decoded "data")))
)
    {"success" (= success 0) "data" data}
)))

(def! call-bank (fn* (req) (let* (
    req (assoc req "to" ROLE_BANK)
    resp (call-contract req)
)
    resp
)))

(def! call-auth (fn* (req) (let* (
    req (assoc req "to" ROLE_AUTH)
    resp (call-contract req)
)
    resp
)))
