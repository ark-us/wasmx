(module

(import "env" "ethereum_useGas" (func $useGas (param i64)))
(import "env" "ethereum_getCallDataSize" (func $getCallDataSize  (result i32)))
(import "env" "ethereum_finish" (func $finish (param i32 i32) ))

;; /*** for cosmwasm
  (type $et12 (func))
  (func $ewasm_interface_version_1 (export "ewasm_interface_version_1") (export "requires_ewasm") (type $et12)
      (nop))

  ;; ********** /

(global $sp (mut i32) (i32.const -32))

;; memory related global
(global $memstart i32  (i32.const 33832))
;; the number of 256 words stored in memory
(global $wordCount (mut i64) (i64.const 0))
;; what was charged for the last memory allocation
(global $prevMemCost (mut i64) (i64.const 0))

;; for SHL, SHR, SAR
(global $global_ (mut i64) (i64.const 0))
(global $global__1 (mut i64) (i64.const 0))
(global $global__2 (mut i64) (i64.const 0))

;; TODO: memory should only be 1, but can't resize right now
(memory 500)
(export "memory" (memory 0))

(func $global_get_sp  (export "GLOBAL_GET_SP") (result i32) (global.get $sp))
(func $global_set_sp  (export "GLOBAL_SET_SP") (param $newsp i32) (global.set $sp (local.get $newsp)))

(func $CALLDATASIZE  (export "CALLDATASIZE") (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getCallDataSize)))
    ;; zero out mem
    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))
    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))
    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))

(func $FINISH (export "FINISH") (param $offset0 i32) (param $length0 i32)
    (call $finish(local.get $offset0)(local.get $length0))
)
  ;; generated by ./wasm/generateInterface.js
(func $PUSH (export "PUSH")
  (param $a0 i64)
  (param $a1 i64)
  (param $a2 i64)
  (param $a3 i64)
  (local $sp i32)

  ;; increament stack pointer
  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))

  (i64.store (local.get $sp) (local.get $a3))
  (i64.store (i32.add (local.get $sp) (i32.const 8)) (local.get $a2))
  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $a1))
  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a0))
)
;; stack:
;;  0: word
;; -1: offset
(func $MSTORE (export "MSTORE")
  (local $sp i32)

  (local $offset   i32)

  (local $offset0 i64)
  (local $offset1 i64)
  (local $offset2 i64)
  (local $offset3 i64)

  ;; load args from the stack
  (local.set $offset0 (i64.load          (global.get $sp)))
  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))
  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))
  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))

  (local.set $offset
             (call $check_overflow (local.get $offset0)
                                   (local.get $offset1)
                                   (local.get $offset2)
                                   (local.get $offset3)))
  ;; subtrace gas useage
  (call $memusegas (local.get $offset) (i32.const 32))

  ;; pop item from the stack
  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))

  ;; swap top stack item
  (drop (call $bswap_m256 (local.get $sp)))

  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))
  ;; store word to memory
  (i64.store          (local.get $offset)                 (i64.load          (local.get $sp)))
  (i64.store (i32.add (local.get $offset) (i32.const 8))  (i64.load (i32.add (local.get $sp) (i32.const  8))))
  (i64.store (i32.add (local.get $offset) (i32.const 16)) (i64.load (i32.add (local.get $sp) (i32.const 16))))
  (i64.store (i32.add (local.get $offset) (i32.const 24)) (i64.load (i32.add (local.get $sp) (i32.const 24))))
)
;; generated by ./wasm/generateInterface.js
(func $RETURN (export "RETURN")  (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow
          (i64.load (global.get $sp))
          (i64.load (i32.add (global.get $sp) (i32.const 8)))
          (i64.load (i32.add (global.get $sp) (i32.const 16)))
          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow
          (i64.load (i32.add (global.get $sp) (i32.const -32)))
          (i64.load (i32.add (global.get $sp) (i32.const -24)))
          (i64.load (i32.add (global.get $sp) (i32.const -16)))
          (i64.load (i32.add (global.get $sp) (i32.const -8)))))
    (call $memusegas (local.get $offset0) (local.get $length0))
    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $finish(local.get $offset0)(local.get $length0)))

(func $memusegas
  (param $offset i32)
  (param $length i32)

  (local $cost i64)
  ;; the number of new words being allocated
  (local $newWordCount i64)

  (if (i32.eqz (local.get $length))
    (then (return))
  )

  ;; const newMemoryWordCount = Math.ceil[[offset + length] / 32]
  (local.set $newWordCount
    (i64.div_u (i64.add (i64.const 31) (i64.add (i64.extend_i32_u (local.get $offset)) (i64.extend_i32_u (local.get $length))))
               (i64.const 32)))

  ;;if [runState.highestMem >= highestMem]  return
  (if (i64.le_u (local.get $newWordCount) (global.get $wordCount))
    (then (return))
  )

  ;; words * 3 + words ^2 / 512
  (local.set $cost
     (i64.add
       (i64.mul (local.get $newWordCount) (i64.const 3))
       (i64.div_u
         (i64.mul (local.get $newWordCount)
                  (local.get $newWordCount))
         (i64.const 512))))

  (call $useGas  (i64.sub (local.get $cost) (global.get $prevMemCost)))
  (global.set $prevMemCost (local.get $cost))
  (global.set $wordCount (local.get $newWordCount))

  ;; grow actual memory
  ;; the first 31704 bytes are guaranteed to be available
  ;; adjust for 32 bytes  - the maximal size of MSTORE write
  ;; TODO it should be memory.size * page_size
  (local.set $offset (i32.add (local.get $length) (i32.add (local.get $offset) (global.get $memstart))))
  (if (i32.gt_u (local.get $offset) (i32.mul (i32.const 65536) (memory.size)))
    (then
      (drop (memory.grow
        (i32.div_u (i32.add (i32.const 65535) (i32.sub (local.get $offset) (memory.size))) (i32.const 65536))))
    )
  )
)
(func $bswap_m256
  (param $sp i32)
  (result i32)
  (local $temp i64)

  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))
  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 24)))))
  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $temp))

  (local.set $temp (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 8)))))
  (i64.store (i32.add (local.get $sp) (i32.const  8)) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 16)))))
  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $temp))
  (local.get $sp)
)
(func $check_overflow
  (param $a i64)
  (param $b i64)
  (param $c i64)
  (param $d i64)
  (result i32)

  (local $MAX_INT i32)
  (local.set $MAX_INT (i32.const -1))

  (if
    (i32.and
      (i32.and
        (i64.eqz  (local.get $d))
        (i64.eqz  (local.get $c)))
      (i32.and
        (i64.eqz  (local.get $b))
        (i64.lt_u (local.get $a) (i64.extend_i32_u (local.get $MAX_INT)))))
     (return (i32.wrap_i64 (local.get $a))))

     (return (local.get $MAX_INT))
)
(func $bswap_i64
  (param $int i64)
  (result i64)

  (i64.or
    (i64.or
      (i64.or
        (i64.and (i64.shr_u (local.get $int) (i64.const 56)) (i64.const 0xff)) ;; 7 -> 0
        (i64.and (i64.shr_u (local.get $int) (i64.const 40)) (i64.const 0xff00))) ;; 6 -> 1
      (i64.or
        (i64.and (i64.shr_u (local.get $int) (i64.const 24)) (i64.const 0xff0000)) ;; 5 -> 2
        (i64.and (i64.shr_u (local.get $int) (i64.const  8)) (i64.const 0xff000000)))) ;; 4 -> 3
    (i64.or
      (i64.or
        (i64.and (i64.shl (local.get $int) (i64.const 8))   (i64.const 0xff00000000)) ;; 3 -> 4
        (i64.and (i64.shl (local.get $int) (i64.const 24))   (i64.const 0xff0000000000))) ;; 2 -> 5
      (i64.or
        (i64.and (i64.shl (local.get $int) (i64.const 40))   (i64.const 0xff000000000000)) ;; 1 -> 6
        (i64.and (i64.shl (local.get $int) (i64.const 56))   (i64.const 0xff00000000000000))))) ;; 0 -> 7
)
)
