package wasmx

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconn"

	//nolint

	sdkmath "cosmossdk.io/math"
	dbm "github.com/cosmos/cosmos-db"
	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519"
	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	"github.com/cosmos/cosmos-sdk/server"
	sdkconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"github.com/cosmos/go-bip39"

	abci "github.com/cometbft/cometbft/abci/types"
	"github.com/cometbft/cometbft/crypto/tmhash"
	"github.com/cometbft/cometbft/libs/bytes"
	"github.com/cometbft/cometbft/node"
	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
	tmprotoversion "github.com/cometbft/cometbft/proto/tendermint/version"
	tmversion "github.com/cometbft/cometbft/proto/tendermint/version"
	cmttypes "github.com/cometbft/cometbft/types"
	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/cometbft/cometbft/version"
	cmtversion "github.com/cometbft/cometbft/version"

	clienttypes "github.com/cosmos/ibc-go/v8/modules/core/02-client/types"
	ibctm "github.com/cosmos/ibc-go/v8/modules/light-clients/07-tendermint"
	ibcgotesting "github.com/cosmos/ibc-go/v8/testing"
	"github.com/cosmos/ibc-go/v8/testing/mock"

	app "github.com/loredanacirstea/wasmx/app"
	mcodec "github.com/loredanacirstea/wasmx/codec"
	mcfg "github.com/loredanacirstea/wasmx/config"
	mctx "github.com/loredanacirstea/wasmx/context"
	menc "github.com/loredanacirstea/wasmx/encoding"
	"github.com/loredanacirstea/wasmx/server/config"
	ibctesting "github.com/loredanacirstea/wasmx/testutil/ibc"
	"github.com/loredanacirstea/wasmx/x/network/keeper"
	"github.com/loredanacirstea/wasmx/x/network/types"
	wasmxtypes "github.com/loredanacirstea/wasmx/x/wasmx/types"

	networkserver "github.com/loredanacirstea/wasmx/x/network/server"
	networkconfig "github.com/loredanacirstea/wasmx/x/network/server/config"

	cosmosmodtypes "github.com/loredanacirstea/wasmx/x/cosmosmod/types"
	memc "github.com/loredanacirstea/wasmx/x/wasmx/vm/memory/common"
)

// KeeperTestSuite is a testing suite to test keeper functions
type KeeperTestSuite struct {
	suite.Suite
	WasmVmMeta            memc.IWasmVmMeta
	TestChain             TestChain
	Chains                map[string]*TestChain
	ChainIds              []string
	CompiledCacheDir      string
	MaxBlockGas           int64
	SystemContractsModify func([]wasmxtypes.SystemContract) []wasmxtypes.SystemContract
	GenesisModify         func(genesisState map[string]json.RawMessage, app ibcgotesting.TestingApp) map[string]json.RawMessage
	GetDB                 func(dbpath string) dbm.DB
}

type TestChain struct {
	T       *testing.T
	ChainId string
	Config  menc.ChainConfig
	ctx     sdk.Context

	App *app.App
	// queryClient types.QueryClient
	// signer      keyring.Signer
	consAddress sdk.ConsAddress
	// validator   stakingtypes.Validator
	Denom           string
	Faucet          *TestFaucet
	ProposerAddress []byte

	LastHeader    *ibctm.Header  // header for last block height committed
	CurrentHeader tmproto.Header // header for current block height
	TxConfig      client.TxConfig
	Codec         codec.Codec

	Vals     *tmtypes.ValidatorSet
	NextVals *tmtypes.ValidatorSet
	Signers  map[string]tmtypes.PrivValidator

	// autogenerated sender private key
	SenderPrivKey        cryptotypes.PrivKey
	SenderAccount        sdk.AccountI
	GovernanceContinuous bool
}

// GetContext returns the current context for the application.
func (chain *TestChain) GetContext() sdk.Context {
	return chain.App.GetBaseApp().NewUncachedContext(false, chain.CurrentHeader)
}

// Called once before any test in the suite
func (suite *KeeperTestSuite) SetupSuite() {
	suite.SetupChains()
}

// Called before each test
func (suite *KeeperTestSuite) SetupTest() {
	// suite.SetupChains()
}

// Called once after all tests in the suite
func (suite *KeeperTestSuite) TearDownSuite() {
	suite.TearDownChains()
}

// Called after each test
func (suite *KeeperTestSuite) TearDownTest() {
	// suite.TearDownChains()
}

func (suite *KeeperTestSuite) GetChain(chainId string) *TestChain {
	chain, ok := suite.Chains[chainId]
	if !ok {
		panic(fmt.Sprintf("cannot find chain: %s", chainId))
	}
	return chain
}

func (suite *KeeperTestSuite) Chain() TestChain {
	return suite.TestChain
}

func (suite *KeeperTestSuite) GetApp(chain *ibcgotesting.TestChain) *app.App {
	return suite.TestChain.App
}

func (suite *KeeperTestSuite) App() *app.App {
	return suite.TestChain.App
}

func (suite *KeeperTestSuite) GetAppContext(chain TestChain) AppContext {
	appContext := AppContext{
		S:                   suite,
		App:                 suite.App(),
		Chain:               chain,
		FinalizeBlockHandle: suite.FinalizeBlockFSM,
	}
	encodingConfig := menc.MakeEncodingConfig(suite.App().GetChainCfg(), app.GetCustomSigners())
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(chain.ChainId)

	t := suite.T()
	addrCodec, ok := encodingConfig.TxConfig.SigningContext().AddressCodec().(mcodec.AccBech32Codec)
	suite.Require().True(ok)
	appContext.Faucet = NewTestFaucet(t, addrCodec, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(chain.Config.BaseDenom, sdkmath.NewInt(1000_000_000_000)))

	return appContext
}

func (suite *KeeperTestSuite) AppContext() AppContext {
	appContext := AppContext{
		S:                   suite,
		App:                 suite.App(),
		Chain:               suite.TestChain,
		FinalizeBlockHandle: suite.FinalizeBlockFSM,
	}
	encodingConfig := menc.MakeEncodingConfig(suite.App().GetChainCfg(), app.GetCustomSigners())
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(suite.TestChain.ChainId)
	t := suite.T()
	denom := appContext.Chain.Config.BaseDenom
	addrCodec := encodingConfig.TxConfig.SigningContext().AddressCodec()
	accBech32Codec := mcodec.MustUnwrapAccBech32Codec(addrCodec)
	appContext.Faucet = NewTestFaucet(t, accBech32Codec, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(denom, sdkmath.NewInt(100_000_000_000)))

	return appContext
}

func (suite *KeeperTestSuite) TearDownChains() {
	for _, chain := range suite.Chains {
		err := chain.App.BaseApp.Close()
		suite.Require().NoError(err)
	}
	if suite.TestChain.App != nil {
		err := suite.TestChain.App.Db().Close()
		suite.Require().NoError(err)
	}
}

func (suite *KeeperTestSuite) SetupChains() {
	t := suite.T()

	if suite.MaxBlockGas > 0 {
		app.DefaultTestingConsensusParams.Block.MaxGas = suite.MaxBlockGas
	}

	suite.Chains = map[string]*TestChain{}
	mcfg.ChainIdsInit = []string{
		mcfg.MYTHOS_CHAIN_ID_TEST,
		mcfg.LEVEL0_CHAIN_ID,
	}
	suite.ChainIds = mcfg.ChainIdsInit
	for i, chainId := range mcfg.ChainIdsInit {
		chaincfg, err := mcfg.GetChainConfig(chainId)
		require.NoError(t, err)
		suite.SetupApp(chainId, chaincfg, int32(i))
	}
	suite.SetCurrentChain(mcfg.MYTHOS_CHAIN_ID_TEST)
}

func (suite *KeeperTestSuite) NewValidator() *tmtypes.Validator {
	t := suite.T()
	// generate validator private/public key
	privVal := mock.NewPV()
	pubKey, err := privVal.GetPubKey()
	require.NoError(t, err)
	// create validator set with single validator
	validator := tmtypes.NewValidator(pubKey, 1)
	return validator
}

func (suite *KeeperTestSuite) SetupApp(chainId string, chaincfg *menc.ChainConfig, index int32) {
	t := suite.T()

	addrCodec := mcodec.MustUnwrapAccBech32Codec(mcodec.NewAccBech32Codec(chaincfg.Bech32PrefixAccAddr, mcodec.NewAddressPrefixedFromAcc))
	// valAddrCodec := mcodec.NewValBech32Codec(chaincfg.Bech32PrefixValAddr, mcodec.NewAddressPrefixedFromVal)

	// generate validator private/public key
	privVal := mock.NewPV()
	pubKey, err := privVal.GetPubKey()
	require.NoError(t, err)

	// create validator set with single validator
	validator := tmtypes.NewValidator(pubKey, 1)
	valSet := tmtypes.NewValidatorSet([]*tmtypes.Validator{validator})
	signersByAddress := make(map[string]tmtypes.PrivValidator, 1)
	signersByAddress[pubKey.Address().String()] = privVal

	// generate genesis account
	senderPrivKey := secp256k1.GenPrivKey()
	authacc := authtypes.NewBaseAccount(senderPrivKey.PubKey().Address().Bytes(), senderPrivKey.PubKey(), 0, 0)
	valOperatorAddress := addrCodec.BytesToAccAddressPrefixed(senderPrivKey.PubKey().Address().Bytes())
	acc := cosmosmodtypes.NewBaseAccount(valOperatorAddress, senderPrivKey.PubKey(), 0, 0)
	amount := sdk.TokensFromConsensusPower(1, sdk.DefaultPowerReduction)

	balance := banktypes.Balance{
		Address: acc.GetAddressPrefixed().String(),
		Coins:   sdk.NewCoins(sdk.NewCoin(chaincfg.BaseDenom, amount)),
	}
	// testApp, resInit := ibctesting.SetupWithGenesisValSet(t, valSet, []cosmosmodtypes.GenesisAccount{acc}, chainId, *chaincfg, index, balance)

	testApp, genesisState, err := ibctesting.BuildGenesisData(suite.WasmVmMeta, valSet, []cosmosmodtypes.GenesisAccount{acc}, chainId, *chaincfg, index, []banktypes.Balance{balance}, suite.CompiledCacheDir, suite.GetDB)
	require.NoError(t, err)

	var wasmxGenState wasmxtypes.GenesisState
	testApp.AppCodec().MustUnmarshalJSON(genesisState[wasmxtypes.ModuleName], &wasmxGenState)

	if strings.Contains(chainId, "level") {
		feeCollectorBech32, err := addrCodec.BytesToString(cosmosmodtypes.NewModuleAddress(wasmxtypes.FEE_COLLECTOR))
		require.NoError(t, err)
		mintAddressBech32, err := addrCodec.BytesToString(cosmosmodtypes.NewModuleAddress("mint"))
		require.NoError(t, err)
		wasmxGenState.SystemContracts = wasmxtypes.DefaultTimeChainContracts(addrCodec, feeCollectorBech32, mintAddressBech32, 1, false, "{}", chaincfg.BondBaseDenom)
	}

	if suite.SystemContractsModify != nil {
		wasmxGenState.SystemContracts = suite.SystemContractsModify(wasmxGenState.SystemContracts)
	}

	genesisState[wasmxtypes.ModuleName] = testApp.AppCodec().MustMarshalJSON(&wasmxGenState)

	if suite.GenesisModify != nil {
		genesisState = suite.GenesisModify(genesisState, testApp)
	}

	testApp, resInit := ibctesting.InitAppChain(t, testApp, genesisState, chainId)

	consAddress := sdk.ConsAddress(senderPrivKey.PubKey().Address())

	// create current header and call begin block
	header := tmproto.Header{
		ChainID:         chainId,
		Height:          1,
		Time:            time.Now().UTC(),
		ProposerAddress: consAddress.Bytes(),
		Version: tmversion.Consensus{
			Block: version.BlockProtocol,
		},
		LastBlockId: tmproto.BlockID{
			Hash: tmhash.Sum([]byte("block_id")),
			PartSetHeader: tmproto.PartSetHeader{
				Total: 11,
				Hash:  tmhash.Sum([]byte("partset_header")),
			},
		},
		AppHash:            tmhash.Sum([]byte("app")),
		DataHash:           tmhash.Sum([]byte("data")),
		EvidenceHash:       tmhash.Sum([]byte("evidence")),
		ValidatorsHash:     tmhash.Sum([]byte("validators")),
		NextValidatorsHash: tmhash.Sum([]byte("next_validators")),
		ConsensusHash:      tmhash.Sum([]byte("consensus")),
		LastResultsHash:    tmhash.Sum([]byte("last_result")),
	}

	txConfig := testApp.GetTxConfig()

	mapp, ok := testApp.(*app.App)
	require.True(t, ok, "not app")
	chain := TestChain{
		T:                    suite.T(),
		ChainId:              chainId,
		Config:               *chaincfg,
		App:                  mapp,
		CurrentHeader:        header,
		TxConfig:             txConfig,
		Codec:                mapp.AppCodec(),
		Vals:                 valSet,
		NextVals:             valSet,
		Signers:              signersByAddress,
		SenderPrivKey:        senderPrivKey,
		SenderAccount:        authacc,
		GovernanceContinuous: false,
	}

	for _, v := range wasmxGenState.SystemContracts {
		if v.Role != nil && v.Role.Role == wasmxtypes.ROLE_GOVERNANCE && v.Role.Primary {
			if v.Label == wasmxtypes.GOV_CONT_v001 {
				chain.GovernanceContinuous = true
			}
		}
	}

	ctx := chain.GetContext()
	mapp.AccountKeeper.SetAccount(ctx, authacc)

	_, err = mapp.Commit()
	require.NoError(t, err)

	suite.TestChain = chain
	suite.Chains[chainId] = &chain

	err = suite.InitConsensusContract(resInit, pubKey.Address(), pubKey.Bytes(), privVal.PrivKey.Bytes(), valOperatorAddress)
	require.NoError(t, err)
}

func (suite *KeeperTestSuite) SetupSubChainApp(mainChainId string, chainId string, chaincfg *menc.ChainConfig, index int32) {
	t := suite.T()
	somechain := suite.GetChain(mainChainId)

	multichainapp, err := somechain.App.GetMultiChainApp()
	suite.Require().NoError(err)

	isubchainapp, err := multichainapp.GetApp(chainId)
	suite.Require().NoError(err)
	testApp, ok := isubchainapp.(ibcgotesting.TestingApp)
	suite.Require().True(ok)
	// if err != nil {
	// 	fmt.Println("setting up new testing app")
	// 	testApp, _ = app.SetupTestingApp(chainId, chaincfg, index)
	// }

	senderPrivateKey := somechain.SenderPrivKey
	consAddress := sdk.ConsAddress(senderPrivateKey.PubKey().Address())
	authacc := authtypes.NewBaseAccount(senderPrivateKey.PubKey().Address().Bytes(), senderPrivateKey.PubKey(), 0, 0)

	// create current header and call begin block
	header := tmproto.Header{
		ChainID:         chainId,
		Height:          1,
		Time:            time.Now().UTC(),
		ProposerAddress: consAddress.Bytes(),
		Version: tmversion.Consensus{
			Block: version.BlockProtocol,
		},
		LastBlockId: tmproto.BlockID{
			Hash: tmhash.Sum([]byte("block_id")),
			PartSetHeader: tmproto.PartSetHeader{
				Total: 11,
				Hash:  tmhash.Sum([]byte("partset_header")),
			},
		},
		AppHash:            tmhash.Sum([]byte("app")),
		DataHash:           tmhash.Sum([]byte("data")),
		EvidenceHash:       tmhash.Sum([]byte("evidence")),
		ValidatorsHash:     tmhash.Sum([]byte("validators")),
		NextValidatorsHash: tmhash.Sum([]byte("next_validators")),
		ConsensusHash:      tmhash.Sum([]byte("consensus")),
		LastResultsHash:    tmhash.Sum([]byte("last_result")),
	}

	txConfig := testApp.GetTxConfig()

	mapp, ok := testApp.(*app.App)
	require.True(t, ok, "not app")
	chain := TestChain{
		T:             suite.T(),
		ChainId:       chainId,
		Config:        *chaincfg,
		App:           mapp,
		CurrentHeader: header,
		TxConfig:      txConfig,
		Codec:         mapp.AppCodec(),
		Vals:          somechain.Vals,
		NextVals:      somechain.Vals,
		Signers:       somechain.Signers,
		SenderPrivKey: somechain.SenderPrivKey,
		SenderAccount: authacc,
	}

	ctx := chain.GetContext()
	mapp.AccountKeeper.SetAccount(ctx, authacc)

	suite.TestChain = chain
	suite.Chains[chainId] = &chain
}

func (suite *KeeperTestSuite) SetCurrentChain(chainId string) {
	chain := suite.GetChain(chainId)
	suite.Require().NotNil(chain)
	suite.TestChain = *chain
}

func (suite *KeeperTestSuite) InitConsensusContract(resInit *abci.ResponseInitChain, nodeAddress bytes.HexBytes, nodePubKey, nodePrivKey []byte, valOperatorAddress mcodec.AccAddressPrefixed) error {
	res, err := suite.App().Info(types.RequestInfo)
	if err != nil {
		return fmt.Errorf("error calling Info: %v", err)
	}
	// vals, err := cmttypes.PB2TM.ValidatorUpdates(resInit.Validators)
	// if err != nil {
	// 	return err
	// }
	// valOperatorAddress := sdk.AccAddress(vals[0].PubKey.Bytes())

	consensusParams := cmttypes.ConsensusParamsFromProto(*app.DefaultTestingConsensusParams)
	if resInit.ConsensusParams != nil {
		consensusParams = consensusParams.Update(resInit.ConsensusParams)
	}

	cfgNetwork := networkconfig.DefaultNetworkConfigConfig()

	currentState := suite.GetCurrentState(suite.TestChain.GetContext())

	peers := []string{}
	if !strings.Contains(currentState, "P2P") && !strings.Contains(currentState, "Level") {
		peers = []string{fmt.Sprintf(`%s@localhost:8090`, valOperatorAddress.String())}
	} else { // P2P, level0, etc
		peers = []string{fmt.Sprintf(`%s@/ip4/127.0.0.1/tcp/5001/p2p/12D3KooWMWpac4Qp74N2SNkcYfbZf2AWHz7cjv69EM5kejbXwBZF`, valOperatorAddress.String())}
	}
	nodeindex, err := strconv.Atoi(cfgNetwork.Id)
	suite.Require().NoError(err)
	err = networkserver.InitConsensusContract(
		suite.App(),
		suite.App().Logger(),
		suite.App().GetNetworkKeeper(),
		resInit.AppHash,
		&consensusParams,
		res.AppVersion,
		nodeAddress,
		nodePubKey,
		nodePrivKey,
		int32(nodeindex),
		peers,
		mctx.NodePorts{},
	)
	if err != nil {
		return err
	}
	msg := []byte(`{"run":{"event": {"type": "start", "params": []}}}`)
	appA := suite.AppContext()
	_, err = suite.App().NetworkKeeper.ExecuteContract(appA.Context(), &types.MsgExecuteContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg,
	})
	suite.raftToLeader()
	return err
}

func (suite *KeeperTestSuite) Commit()                                               {}
func (suite *KeeperTestSuite) CommitNBlocks(chain *ibcgotesting.TestChain, n uint64) {}
func (suite *KeeperTestSuite) Coordinator() *ibcgotesting.Coordinator {
	return nil
}
func (suite *KeeperTestSuite) CommitNBlocks_(chain TestChain, n uint64) {
	for i := 0; i < int(n); i++ {
		_, err := suite.CommitBlock()
		suite.Require().NoError(err)
	}
}

func (s *KeeperTestSuite) GetRandomAccount() simulation.Account {
	pk := ed25519.GenPrivKey()
	privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

func (s *KeeperTestSuite) GetAccountFromMnemonic(mnemonic string) simulation.Account {
	s.Require().True(bip39.IsMnemonicValid(mnemonic))
	hdPath := hd.CreateHDPath(118, 0, 0).String()
	derivedPriv, err := hd.Secp256k1.Derive()(mnemonic, "", hdPath)
	s.Require().NoError(err)
	privKey := hd.Secp256k1.Generate()(derivedPriv)

	// privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

const bufSize = 1024 * 1024

func GrpcSetup(t *testing.T, mapp *app.App) *bufconn.Listener {
	goctx := context.Background()
	serverCtx := server.NewDefaultContext()
	clientCtx := client.Context{}.WithTxConfig(mapp.TxConfig()).WithChainID(mapp.ChainID())
	config, err := config.GetConfig(serverCtx.Viper)
	require.NoError(t, err)

	lis := bufconn.Listen(bufSize)
	grpcServer, err := NewGRPCServer(goctx, serverCtx, clientCtx, &config, mapp, nil)
	require.NoError(t, err)

	go func() {
		if err := grpcServer.Serve(lis); err != nil {
			log.Fatalf("Server exited with error: %v", err)
		}
	}()
	return lis
}

func (suite *KeeperTestSuite) GrpcClient(ctx context.Context, target string, mapp *app.App) (types.MsgClient, *grpc.ClientConn) {
	t := suite.T()
	lis := GrpcSetup(t, mapp)
	bufDialer := func(context.Context, string) (net.Conn, error) {
		return lis.Dial()
	}
	// target := "bufnet"
	conn, err := grpc.DialContext(ctx, target, grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
	if err != nil {
		t.Fatalf("Failed to dial bufnet: %v", err)
	}
	return types.NewMsgClient(conn), conn
}

func NewGRPCServer(
	ctx context.Context,
	svrCtx *server.Context,
	clientCtx client.Context,
	cfg *config.Config,
	app servertypes.Application,
	tmNode *node.Node,
) (*grpc.Server, error) {
	grpccfg := cfg.GRPC
	maxSendMsgSize := grpccfg.MaxSendMsgSize
	if maxSendMsgSize == 0 {
		maxSendMsgSize = sdkconfig.DefaultGRPCMaxSendMsgSize
	}

	maxRecvMsgSize := grpccfg.MaxRecvMsgSize
	if maxRecvMsgSize == 0 {
		maxRecvMsgSize = sdkconfig.DefaultGRPCMaxRecvMsgSize
	}

	grpcSrv := grpc.NewServer(
		grpc.ForceServerCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
		grpc.MaxSendMsgSize(maxSendMsgSize),
		grpc.MaxRecvMsgSize(maxRecvMsgSize),
	)

	_, err := keeper.RegisterGRPCServer(ctx, svrCtx, clientCtx, cfg, app, grpcSrv)
	if err != nil {
		return nil, fmt.Errorf("failed to register grpc server: %w", err)
	}
	return grpcSrv, nil
}

func (suite *KeeperTestSuite) AddToMempoolFSM(txs [][]byte) ([]*types.MsgExecuteContractResponse, error) {
	app := suite.TestChain.App
	cb := func(goctx context.Context) (any, error) {
		resps := make([]*types.MsgExecuteContractResponse, 0)
		for _, tx := range txs {
			msg := []byte(fmt.Sprintf(`{"run":{"event":{"type":"newTransaction","params":[{"key":"transaction", "value":"%s"}]}}}`, base64.StdEncoding.EncodeToString(tx)))
			resp, err := suite.TestChain.App.NetworkKeeper.ExecuteContract(suite.TestChain.GetContext(), &types.MsgExecuteContract{
				Sender:   wasmxtypes.ROLE_CONSENSUS,
				Contract: wasmxtypes.ROLE_CONSENSUS,
				Msg:      msg,
			})
			if err != nil {
				return nil, err
			}
			resps = append(resps, resp)
		}
		return resps, nil
	}
	resp, err := app.GetActionExecutor().(*keeper.ActionExecutor).Execute(app.GetGoContextParent(), app.LastBlockHeight(), sdk.ExecModeFinalize, cb)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, nil
	}
	return resp.([]*types.MsgExecuteContractResponse), nil
}

func (suite *KeeperTestSuite) FinalizeBlockFSM(txs [][]byte) (*abci.ResponseFinalizeBlock, error) {
	_, err := suite.AddToMempoolFSM(txs)
	if err != nil {
		suite.App().Logger().Error(fmt.Sprintf("adding tx to mempool: %s", err.Error()))
		return &abci.ResponseFinalizeBlock{TxResults: []*abci.ExecTxResult{{Code: 11, Log: err.Error()}}}, nil
	}
	return suite.CommitBlock()
}

func (suite *KeeperTestSuite) CommitBlock() (*abci.ResponseFinalizeBlock, error) {
	lastInterval := suite.GetLastInterval(suite.TestChain.GetContext())
	currentState := suite.GetCurrentState(suite.TestChain.GetContext())
	blockDelay := suite.GetBlockDelay(suite.TestChain.GetContext())
	prevBlock := suite.App().LastBlockHeight()

	app := suite.TestChain.App
	cb := func(blockDelay, currentState, lastInterval string) func(goctx context.Context) (any, error) {
		return func(goctx context.Context) (any, error) {
			msg1 := []byte(fmt.Sprintf(`{"delay":"%s","state":"%s","intervalId":%s}`, blockDelay, currentState, lastInterval))
			_, err := suite.TestChain.App.NetworkKeeper.ExecuteEntryPoint(suite.TestChain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
				Sender:   wasmxtypes.ROLE_CONSENSUS,
				Contract: wasmxtypes.ROLE_CONSENSUS,
				Msg:      msg1,
			})
			if err != nil {
				return nil, err
			}
			return nil, nil
		}
	}
	_, err := app.GetActionExecutor().(*keeper.ActionExecutor).Execute(app.GetGoContextParent(), app.LastBlockHeight(), sdk.ExecModeFinalize, cb(blockDelay, currentState, lastInterval))
	if err != nil {
		return nil, err
	}

	if strings.Contains(strings.ToLower(currentState), "ondemand") {
		lastInterval = suite.GetLastInterval(suite.TestChain.GetContext())
		currentState = suite.GetCurrentState(suite.TestChain.GetContext())
		_, err := app.GetActionExecutor().(*keeper.ActionExecutor).Execute(app.GetGoContextParent(), app.LastBlockHeight(), sdk.ExecModeFinalize, cb("batchTimeout", currentState, lastInterval))
		if err != nil {
			return nil, err
		}
	}
	lastBlock := suite.App().LastBlockHeight()
	if prevBlock >= lastBlock {
		// in case a test just changed consensus to RAFT, we help the test move faster through all the protocols delays that happen when choosing the Leader
		if strings.Contains(currentState, "RAFT") && !strings.Contains(currentState, "Leader") {
			if strings.Contains(currentState, "initialized.prestart") {
				// this state waits 500ms and then goes to "initialized.Follower"
				time.Sleep(time.Second * 10)
			}
			currentState := suite.GetCurrentState(suite.TestChain.GetContext())
			if strings.Contains(currentState, "initialized.Follower") {
				// we need to get the node to Leader state faster
				suite.raftToLeader()
			}
			currentState = suite.GetCurrentState(suite.TestChain.GetContext())
			lastBlock := suite.App().LastBlockHeight()
			if prevBlock >= lastBlock {
				return nil, fmt.Errorf("chain %s has not advanced: last block %d, expected %d", suite.TestChain.ChainId, lastBlock, prevBlock+1)
			}
		} else {
			return nil, fmt.Errorf("chain %s has not advanced: last block %d, expected %d", suite.TestChain.ChainId, lastBlock, prevBlock+1)
		}
	}
	res, _, _, err := suite.GetBlock(suite.TestChain.GetContext(), lastBlock)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (suite *KeeperTestSuite) GetBlockDelay(ctx sdk.Context) string {
	return suite.GetContextValue(ctx, types.BLOCK_DELAY, wasmxtypes.ROLE_CONSENSUS)
}

func (suite *KeeperTestSuite) GetCurrentState(ctx sdk.Context) string {
	msg := []byte(`{"getCurrentState":{}}`)
	resp, err := suite.TestChain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetContextValue(ctx sdk.Context, key string, addr string) string {
	msg := []byte(fmt.Sprintf(`{"getContextValue":{"key":"%s"}}`, key))
	resp, err := suite.TestChain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   addr,
		Contract: addr,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetLastInterval(ctx sdk.Context) string {
	key := types.GetLastIntervalIdKey()
	value := suite.GetContextValue(ctx, key, wasmxtypes.ROLE_CONSENSUS)
	if value == "" {
		value = "0"
	}
	return value
}

func (suite *KeeperTestSuite) GetLastIntervalIdByStateKey(ctx sdk.Context, state string, delay string) string {
	key := types.GetLastIntervalIdByStateKey(state, delay)
	value := suite.GetContextValue(ctx, key, wasmxtypes.ROLE_CONSENSUS)
	if value == "" {
		value = "0"
	}
	return value
}

func (suite *KeeperTestSuite) GetBlock(ctx sdk.Context, height int64) (*abci.ResponseFinalizeBlock, *cmttypes.Header, *cmttypes.Commit, error) {
	key := types.GetBlockKey(height)
	data := suite.GetContextValue(ctx, key, wasmxtypes.ROLE_STORAGE)
	if len(data) == 0 {
		return nil, nil, nil, fmt.Errorf("tx block (%d) not found", height)
	}
	var entry types.BlockEntry
	err := json.Unmarshal([]byte(data), &entry)
	if err != nil {
		return nil, nil, nil, err
	}
	var blockResultData abci.ResponseFinalizeBlock
	err = json.Unmarshal(entry.Result, &blockResultData)
	if err != nil {
		return nil, nil, nil, err
	}

	var header cmttypes.Header
	err = json.Unmarshal(entry.Header, &header)
	if err != nil {
		return nil, nil, nil, err
	}

	var lastCommit cmttypes.Commit
	err = json.Unmarshal(entry.LastCommit, &lastCommit)
	if err != nil {
		return nil, nil, nil, err
	}

	return &blockResultData, &header, &lastCommit, nil
}

func (suite *KeeperTestSuite) raftToLeader() {
	currentState := suite.GetCurrentState(suite.TestChain.GetContext())
	// get consensus version
	if strings.Contains(currentState, "#RAFT") && strings.Contains(currentState, "initialized.Follower") {
		lastInterval := suite.GetLastIntervalIdByStateKey(suite.TestChain.GetContext(), currentState, "electionTimeout")
		msg1 := []byte(fmt.Sprintf(`{"delay":"electionTimeout","state":"%s","intervalId":%s}`, currentState, lastInterval))
		_, err := suite.TestChain.App.NetworkKeeper.ExecuteEntryPoint(suite.TestChain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
			Sender:   wasmxtypes.ROLE_CONSENSUS,
			Contract: wasmxtypes.ROLE_CONSENSUS,
			Msg:      msg1,
		})
		suite.Require().NoError(err)

		// raft p2p
		currentState = suite.GetCurrentState(suite.TestChain.GetContext())
		if strings.Contains(currentState, "Follower") {
			// we need some time for the protocol to arrive at Candidate state
			time.Sleep(time.Second * 5)
		}

		currentState = suite.GetCurrentState(suite.TestChain.GetContext())
		if strings.Contains(currentState, "Candidate") {
			lastInterval := suite.GetLastIntervalIdByStateKey(suite.TestChain.GetContext(), currentState, "electionTimeout")
			msg1 = []byte(fmt.Sprintf(`{"delay":"electionTimeout","state":"%s","intervalId":%s}`, currentState, lastInterval))
			_, err = suite.TestChain.App.NetworkKeeper.ExecuteEntryPoint(suite.TestChain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
				Sender:   wasmxtypes.ROLE_CONSENSUS,
				Contract: wasmxtypes.ROLE_CONSENSUS,
				Msg:      msg1,
			})
			suite.Require().NoError(err)
		}
		currentState = suite.GetCurrentState(suite.TestChain.GetContext())
		suite.Require().Contains(currentState, "Leader")
	}
}

func (suite *KeeperTestSuite) commitBlock(res *abci.ResponseFinalizeBlock) {
	_, err := suite.TestChain.App.Commit()
	require.NoError(suite.T(), err)

	// set the last header to the current header
	// use nil trusted fields
	suite.TestChain.LastHeader = suite.TestChain.CurrentTMClientHeader()

	// val set changes returned from previous block get applied to the next validators
	// of this block. See tendermint spec for details.
	suite.TestChain.Vals = suite.TestChain.NextVals
	suite.TestChain.NextVals = ibcgotesting.ApplyValSetChanges(suite.T(), suite.TestChain.Vals, res.ValidatorUpdates)

	// increment the current header
	suite.TestChain.CurrentHeader = tmproto.Header{
		ChainID: suite.TestChain.ChainId,
		Height:  suite.TestChain.App.LastBlockHeight() + 1,
		AppHash: suite.TestChain.App.LastCommitID().Hash,
		// NOTE: the time is increased by the coordinator to maintain time synchrony amongst
		// chains.
		Time:               suite.TestChain.CurrentHeader.Time,
		ValidatorsHash:     suite.TestChain.Vals.Hash(),
		NextValidatorsHash: suite.TestChain.NextVals.Hash(),
		ProposerAddress:    suite.TestChain.CurrentHeader.ProposerAddress,
	}
}

func (suite *KeeperTestSuite) ParseQueryResponse(qres []byte, qresp interface{}) {
	err := json.Unmarshal(qres, qresp)
	suite.Require().NoError(err)
}

// CreateTMClientHeader creates a TM header to update the TM client. Args are passed in to allow
// caller flexibility to use params that differ from the chain.
func (chain *TestChain) CreateTMClientHeader(chainID string, blockHeight int64, trustedHeight clienttypes.Height, timestamp time.Time, cmtValSet, nextVals, tmTrustedVals *cmttypes.ValidatorSet, signers map[string]cmttypes.PrivValidator) *ibctm.Header {
	var (
		valSet      *tmproto.ValidatorSet
		trustedVals *tmproto.ValidatorSet
	)
	require.NotNil(chain.T, cmtValSet)

	tmHeader := cmttypes.Header{
		Version:            tmprotoversion.Consensus{Block: cmtversion.BlockProtocol, App: 2},
		ChainID:            chainID,
		Height:             blockHeight,
		Time:               timestamp,
		LastBlockID:        MakeBlockID(make([]byte, tmhash.Size), 10_000, make([]byte, tmhash.Size)),
		LastCommitHash:     chain.App.LastCommitID().Hash,
		DataHash:           tmhash.Sum([]byte("data_hash")),
		ValidatorsHash:     cmtValSet.Hash(),
		NextValidatorsHash: nextVals.Hash(),
		ConsensusHash:      tmhash.Sum([]byte("consensus_hash")),
		AppHash:            chain.CurrentHeader.AppHash,
		LastResultsHash:    tmhash.Sum([]byte("last_results_hash")),
		EvidenceHash:       tmhash.Sum([]byte("evidence_hash")),
		ProposerAddress:    cmtValSet.Proposer.Address, //nolint:staticcheck
	}

	hhash := tmHeader.Hash()
	blockID := MakeBlockID(hhash, 3, tmhash.Sum([]byte("part_set")))
	voteSet := cmttypes.NewVoteSet(chainID, blockHeight, 1, tmproto.PrecommitType, cmtValSet)

	// MakeCommit expects a signer array in the same order as the validator array.
	// Thus we iterate over the ordered validator set and construct a signer array
	// from the signer map in the same order.
	var signerArr []cmttypes.PrivValidator   //nolint:prealloc // using prealloc here would be needlessly complex
	for _, v := range cmtValSet.Validators { //nolint:staticcheck // need to check for nil validator set
		signerArr = append(signerArr, signers[v.Address.String()])
	}

	extCommit, err := cmttypes.MakeExtCommit(blockID, blockHeight, 1, voteSet, signerArr, timestamp, false)
	require.NoError(chain.T, err)

	signedHeader := &tmproto.SignedHeader{
		Header: tmHeader.ToProto(),
		Commit: extCommit.ToCommit().ToProto(),
	}

	if cmtValSet != nil { //nolint:staticcheck
		valSet, err = cmtValSet.ToProto()
		require.NoError(chain.T, err)
	}

	if tmTrustedVals != nil {
		trustedVals, err = tmTrustedVals.ToProto()
		require.NoError(chain.T, err)
	}

	// The trusted fields may be nil. They may be filled before relaying messages to a client.
	// The relayer is responsible for querying client and injecting appropriate trusted fields.
	return &ibctm.Header{
		SignedHeader:      signedHeader,
		ValidatorSet:      valSet,
		TrustedHeight:     trustedHeight,
		TrustedValidators: trustedVals,
	}
}

func (chain *TestChain) CurrentTMClientHeader() *ibctm.Header {
	return chain.CreateTMClientHeader(
		chain.ChainId,
		chain.CurrentHeader.Height,
		clienttypes.Height{},
		chain.CurrentHeader.Time,
		chain.Vals,
		chain.NextVals,
		nil,
		chain.Signers,
	)
}

// MakeBlockID copied unimported test functions from cmttypes to use them here
func MakeBlockID(hash []byte, partSetSize uint32, partSetHash []byte) cmttypes.BlockID {
	return cmttypes.BlockID{
		Hash: hash,
		PartSetHeader: cmttypes.PartSetHeader{
			Total: partSetSize,
			Hash:  partSetHash,
		},
	}
}
