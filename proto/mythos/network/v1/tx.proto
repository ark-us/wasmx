syntax = "proto3";
package mythos.network.v1;

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";
import "google/protobuf/any.proto";
import "cosmos/base/v1beta1/coin.proto";
import "mythos/network/v1/tendermint.proto";
import "mythos/network/v1/custom.proto";

option go_package = "mythos/v1/x/network/types";
option (gogoproto.goproto_getters_all) = false;

// Msg defines the grpc server
service Msg {
    option (cosmos.msg.v1.service) = true;

    // needed by wasmx module

    // GrpcSendRequest
    rpc GrpcSendRequest(MsgGrpcSendRequest) returns (MsgGrpcSendRequestResponse);

    // StartTimeout
    rpc StartTimeout(MsgStartTimeoutRequest) returns (MsgStartTimeoutResponse);

    rpc StartBackgroundProcess(MsgStartBackgroundProcessRequest) returns (MsgStartBackgroundProcessResponse);

    // MultiChainWrap wraps a message to be executed on one of the available chains
    rpc MultiChainWrap(MsgMultiChainWrap) returns (MsgMultiChainWrapResponse);

    // this is external, for the grpc server
    // TODO remove from the message server, only keep for grpc?

    // GrpcReceiveRequest
    rpc GrpcReceiveRequest(MsgGrpcReceiveRequest) returns (MsgGrpcReceiveRequestResponse);

    // P2PReceiveMessage
    rpc P2PReceiveMessage(MsgP2PReceiveMessageRequest) returns (MsgP2PReceiveMessageResponse);

    rpc ExecuteAtomicTx(MsgExecuteAtomicTxRequest) returns (MsgExecuteAtomicTxResponse);

    // only executed internally, sent by wasmx
    rpc ExecuteCrossChainTx(MsgExecuteCrossChainTxRequest) returns (MsgExecuteCrossChainTxResponse);
}

message MsgExecuteCrossChainTxRequestIndexed {
    option (amino.name) = "network/MsgExecuteCrossChainTxRequestIndexed";

    MsgExecuteCrossChainTxRequest request = 1;
    int32 index = 2;
}

message MsgExecuteCrossChainTxResponseIndexed {
    option (amino.name) = "network/MsgExecuteCrossChainTxResponseIndexed";

    MsgExecuteCrossChainTxResponse data = 1;
    int32 index = 2;
}

message MsgExecuteCrossChainTxRequest {
    option (amino.name) = "network/MsgExecuteCrossChainTxRequest";
    option (cosmos.msg.v1.signer) = "from";

    option (gogoproto.equal)           = false;
    option (gogoproto.goproto_getters) = true;

    // from is the contract that signed the messages
    string from = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    // to is the address of the smart contract on the current chain
    string to_address_or_role = 2;
    // Msg json encoded message to be passed to the contract
    bytes msg = 3 [(gogoproto.casttype) = "RawContractMessage"];
    // Funds coins that are transferred to the contract on execution
    repeated cosmos.base.v1beta1.Coin funds = 4 [
        (gogoproto.nullable) = false,
        (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
    ];
    // Array of either hex-encoded contract addresses or contract labels
    // on which the execution of this message depends on
    repeated string dependencies = 5;
    string from_chain_id = 6;
    string from_role = 7;
    string to_chain_id = 8;
}

message MsgExecuteCrossChainTxResponse {
    bytes data = 1;
    string error = 2;
}

message MsgExecuteAtomicTxResponse {
    repeated ExecTxResult results = 1 [(gogoproto.nullable) = false];
}

message MsgMultiChainWrap {
    option (amino.name) = "network/MsgMultiChainWrap";
    option (cosmos.msg.v1.signer) = "sender";

    option (gogoproto.equal)           = false;
    option (gogoproto.goproto_getters) = true;
    string multi_chain_id = 1;
    string sender = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    google.protobuf.Any data = 3;
}

message MsgMultiChainWrapResponse {
    bytes data = 1;
}

message MsgGrpcSendRequest {
    option (cosmos.msg.v1.signer) = "sender";
    // this will always be the network module
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    string ip_address = 3;
	bytes data = 4;
    string encoding = 5; // evm, json, protobuf // ?
}

message MsgGrpcSendRequestResponse {
	bytes data = 1;
}

message MsgGrpcReceiveRequest {
    option (cosmos.msg.v1.signer) = "sender";
    // this will always be the network module
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
	bytes data = 3;
    string encoding = 4; // evm, json, protobuf // ?
}

message MsgGrpcReceiveRequestResponse {
	bytes data = 1;
}

// MsgStartTimeoutRequest
message MsgStartTimeoutRequest {
    option (cosmos.msg.v1.signer) = "sender";
    // this will always be the wasmx module // TODO authority
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    // contract address
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    int64 delay = 3;
    bytes args = 4;
}

// MsgStartTimeoutResponse
message MsgStartTimeoutResponse {}

// MsgStartBackgroundProcessRequest
message MsgStartBackgroundProcessRequest {
    option (cosmos.msg.v1.signer) = "sender";
    // this will always be the wasmx module // TODO authority
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    // contract address
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    bytes args = 3;
}

// MsgStartBackgroundProcessResponse
message MsgStartBackgroundProcessResponse {}

// ExecuteContract
message MsgExecuteContract {
    option (amino.name) = "network/MsgExecuteContract";
    option (cosmos.msg.v1.signer) = "sender";
    // Sender is the that actor that signed the messages
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    // Contract is the address of the smart contract
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    // Msg json encoded message to be passed to the contract
    bytes msg = 3;
    // Funds coins that are transferred to the contract on execution
    // repeated cosmos.base.v1beta1.Coin funds = 4 [
    //     (gogoproto.nullable) = false,
    //     (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
    // ];
    // // Array of either hex-encoded contract addresses or contract labels
    // // on which the execution of this message depends on
    // repeated string dependencies = 5;
}

// ExecuteContractResponse
message MsgExecuteContractResponse {
    bytes data = 1;
}

// QueryContract
message MsgQueryContract {
    option (amino.name) = "wasmx/MsgQueryContract";
    option (cosmos.msg.v1.signer) = "sender";
    // Sender is the that actor that signed the messages
    string sender = 1;
    // Address is the address of the smart contract
    string contract = 2;
    bytes msg = 3;
    // // Funds coins that are transferred to the contract on execution
    // repeated cosmos.base.v1beta1.Coin funds = 4 [
    //     (gogoproto.nullable) = false,
    //     (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
    // ];
    // // Array of either hex-encoded contract addresses or contract labels
    // // on which the execution of this message depends on
    // repeated string dependencies = 5;
}

// QueryContractResponse
message MsgQueryContractResponse {
    bytes data = 1;
}

message MsgP2PReceiveMessageRequest {
    option (cosmos.msg.v1.signer) = "sender";
    // this will always be the network module
    string sender = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
    string contract = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
	bytes data = 3;
}

message MsgP2PReceiveMessageResponse {}

// ExtensionOptionMultiChainTx is an extension option for multichain atomic transactions
message ExtensionOptionMultiChainTx {
    // option (gogoproto.goproto_getters) = false;
    string chain_id = 1;
    int32 index = 2; // index of this transaction in the atomic set
    int32 tx_count = 3; // total transactions in the atomic set
}

// ExtensionOptionMultiChainTx is an extension option for multichain atomic transactions
message ExtensionOptionAtomicMultiChainTx {
    option (gogoproto.goproto_getters) = false;
}
