package wasmx

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconn"

	//nolint

	sdkmath "cosmossdk.io/math"
	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519"
	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	"github.com/cosmos/cosmos-sdk/server"
	sdkconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"github.com/cosmos/go-bip39"

	abci "github.com/cometbft/cometbft/abci/types"
	"github.com/cometbft/cometbft/crypto/tmhash"
	"github.com/cometbft/cometbft/libs/bytes"
	"github.com/cometbft/cometbft/node"
	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
	tmprotoversion "github.com/cometbft/cometbft/proto/tendermint/version"
	tmversion "github.com/cometbft/cometbft/proto/tendermint/version"
	cmttypes "github.com/cometbft/cometbft/types"
	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/cometbft/cometbft/version"
	cmtversion "github.com/cometbft/cometbft/version"

	clienttypes "github.com/cosmos/ibc-go/v8/modules/core/02-client/types"
	ibctm "github.com/cosmos/ibc-go/v8/modules/light-clients/07-tendermint"
	ibcgotesting "github.com/cosmos/ibc-go/v8/testing"
	"github.com/cosmos/ibc-go/v8/testing/mock"

	app "mythos/v1/app"
	mcodec "mythos/v1/codec"
	mcfg "mythos/v1/config"
	menc "mythos/v1/encoding"
	"mythos/v1/server/config"
	ibctesting "mythos/v1/testutil/ibc"
	"mythos/v1/x/network/keeper"
	"mythos/v1/x/network/types"
	wasmxkeeper "mythos/v1/x/wasmx/keeper"
	wasmxtypes "mythos/v1/x/wasmx/types"

	networkserver "mythos/v1/x/network/server"
	networkconfig "mythos/v1/x/network/server/config"

	cosmosmodtypes "mythos/v1/x/cosmosmod/types"
)

// KeeperTestSuite is a testing suite to test keeper functions
type KeeperTestSuite struct {
	suite.Suite
	chain    TestChain
	chains   map[string]*TestChain
	ChainIds []string
}

type TestChain struct {
	T       *testing.T
	ChainId string
	Config  menc.ChainConfig
	ctx     sdk.Context

	App *app.App
	// queryClient types.QueryClient
	// signer      keyring.Signer
	consAddress sdk.ConsAddress
	// validator   stakingtypes.Validator
	Denom           string
	Faucet          *wasmxkeeper.TestFaucet
	ProposerAddress []byte

	LastHeader    *ibctm.Header  // header for last block height committed
	CurrentHeader tmproto.Header // header for current block height
	TxConfig      client.TxConfig
	Codec         codec.Codec

	Vals     *tmtypes.ValidatorSet
	NextVals *tmtypes.ValidatorSet
	Signers  map[string]tmtypes.PrivValidator

	// autogenerated sender private key
	SenderPrivKey cryptotypes.PrivKey
	SenderAccount sdk.AccountI
}

// GetContext returns the current context for the application.
func (chain *TestChain) GetContext() sdk.Context {
	return chain.App.GetBaseApp().NewUncachedContext(false, chain.CurrentHeader)
}

func (suite *KeeperTestSuite) GetChain(chainId string) *TestChain {
	chain, ok := suite.chains[chainId]
	if !ok {
		panic(fmt.Sprintf("cannot find chain: %s", chainId))
	}
	return chain
}

func (suite *KeeperTestSuite) Chain() TestChain {
	return suite.chain
}

func (suite *KeeperTestSuite) GetApp(chain *ibcgotesting.TestChain) *app.App {
	return suite.chain.App
}

func (suite *KeeperTestSuite) App() *app.App {
	return suite.chain.App
}

func (suite *KeeperTestSuite) GetAppContext(chain TestChain) AppContext {
	appContext := AppContext{
		S:             suite,
		App:           suite.App(),
		Chain:         chain,
		FinalizeBlock: suite.FinalizeBlock,
	}
	encodingConfig := menc.MakeEncodingConfig(suite.App().GetChainCfg())
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(chain.ChainId)

	t := suite.T()
	addrCodec, ok := encodingConfig.TxConfig.SigningContext().AddressCodec().(mcodec.AccBech32Codec)
	suite.Require().True(ok)
	appContext.Faucet = wasmxkeeper.NewTestFaucet(t, addrCodec, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(chain.Config.BaseDenom, sdkmath.NewInt(100_000_000_000)))

	return appContext
}

func (suite *KeeperTestSuite) AppContext() AppContext {
	appContext := AppContext{
		S:             suite,
		App:           suite.App(),
		Chain:         suite.chain,
		FinalizeBlock: suite.FinalizeBlock,
	}
	encodingConfig := menc.MakeEncodingConfig(suite.App().GetChainCfg())
	appContext.ClientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig).WithChainID(suite.chain.ChainId)
	t := suite.T()
	denom := appContext.Chain.Config.BaseDenom
	addrCodec := encodingConfig.TxConfig.SigningContext().AddressCodec()
	accBech32Codec := mcodec.MustUnwrapAccBech32Codec(addrCodec)
	appContext.Faucet = wasmxkeeper.NewTestFaucet(t, accBech32Codec, appContext.Context(), suite.App().BankKeeper, wasmxtypes.ModuleName, sdk.NewCoin(denom, sdkmath.NewInt(100_000_000_000)))

	return appContext
}

func (suite *KeeperTestSuite) SetupTest() {
	suite.chains = map[string]*TestChain{}
	mcfg.ChainIdsInit = []string{
		mcfg.MYTHOS_CHAIN_ID_TEST,
		mcfg.LEVEL0_CHAIN_ID,
	}
	suite.ChainIds = mcfg.ChainIdsInit
	for i, chainId := range mcfg.ChainIdsInit {
		suite.SetupApp(chainId, int32(i))
	}
}

func (suite *KeeperTestSuite) SetupApp(chainId string, index int32) {
	t := suite.T()
	chaincfg, err := mcfg.GetChainConfig(chainId)
	require.NoError(t, err)

	addrCodec := mcodec.MustUnwrapAccBech32Codec(mcodec.NewAccBech32Codec(chaincfg.Bech32PrefixAccAddr, mcodec.NewAddressPrefixedFromAcc))
	// valAddrCodec := mcodec.NewValBech32Codec(chaincfg.Bech32PrefixValAddr, mcodec.NewAddressPrefixedFromVal)

	// generate validator private/public key
	privVal := mock.NewPV()
	pubKey, err := privVal.GetPubKey()
	require.NoError(t, err)

	// create validator set with single validator
	validator := tmtypes.NewValidator(pubKey, 1)
	valSet := tmtypes.NewValidatorSet([]*tmtypes.Validator{validator})
	signersByAddress := make(map[string]tmtypes.PrivValidator, 1)
	signersByAddress[pubKey.Address().String()] = privVal

	// generate genesis account
	senderPrivKey := secp256k1.GenPrivKey()
	authacc := authtypes.NewBaseAccount(senderPrivKey.PubKey().Address().Bytes(), senderPrivKey.PubKey(), 0, 0)
	valOperatorAddress := addrCodec.BytesToAccAddressPrefixed(senderPrivKey.PubKey().Address().Bytes())
	acc := cosmosmodtypes.NewBaseAccount(valOperatorAddress, senderPrivKey.PubKey(), 0, 0)
	amount := sdk.TokensFromConsensusPower(1, sdk.DefaultPowerReduction)

	balance := banktypes.Balance{
		Address: acc.GetAddressPrefixed().String(),
		Coins:   sdk.NewCoins(sdk.NewCoin(chaincfg.BaseDenom, amount)),
	}
	// testApp, resInit := ibctesting.SetupWithGenesisValSet(t, valSet, []cosmosmodtypes.GenesisAccount{acc}, chainId, *chaincfg, index, balance)

	testApp, genesisState, err := ibctesting.BuildGenesisData(valSet, []cosmosmodtypes.GenesisAccount{acc}, chainId, *chaincfg, index, []banktypes.Balance{balance})
	require.NoError(t, err)
	if strings.Contains(chainId, "level") {
		feeCollectorBech32, err := addrCodec.BytesToString(cosmosmodtypes.NewModuleAddress(mcfg.FEE_COLLECTOR))
		require.NoError(t, err)
		mintAddressBech32, err := addrCodec.BytesToString(cosmosmodtypes.NewModuleAddress("mint"))
		require.NoError(t, err)

		var wasmxGenState wasmxtypes.GenesisState
		testApp.AppCodec().MustUnmarshalJSON(genesisState[wasmxtypes.ModuleName], &wasmxGenState)
		wasmxGenState.SystemContracts = wasmxtypes.DefaultTimeChainContracts(feeCollectorBech32, mintAddressBech32)
		genesisState[wasmxtypes.ModuleName] = testApp.AppCodec().MustMarshalJSON(&wasmxGenState)
	}
	testApp, resInit := ibctesting.InitAppChain(t, testApp, genesisState, chainId)

	consAddress := sdk.ConsAddress(senderPrivKey.PubKey().Address())

	// create current header and call begin block
	header := tmproto.Header{
		ChainID:         chainId,
		Height:          1,
		Time:            time.Now().UTC(),
		ProposerAddress: consAddress.Bytes(),
		Version: tmversion.Consensus{
			Block: version.BlockProtocol,
		},
		LastBlockId: tmproto.BlockID{
			Hash: tmhash.Sum([]byte("block_id")),
			PartSetHeader: tmproto.PartSetHeader{
				Total: 11,
				Hash:  tmhash.Sum([]byte("partset_header")),
			},
		},
		AppHash:            tmhash.Sum([]byte("app")),
		DataHash:           tmhash.Sum([]byte("data")),
		EvidenceHash:       tmhash.Sum([]byte("evidence")),
		ValidatorsHash:     tmhash.Sum([]byte("validators")),
		NextValidatorsHash: tmhash.Sum([]byte("next_validators")),
		ConsensusHash:      tmhash.Sum([]byte("consensus")),
		LastResultsHash:    tmhash.Sum([]byte("last_result")),
	}

	txConfig := testApp.GetTxConfig()

	mapp, ok := testApp.(*app.App)
	require.True(t, ok, "not app")
	chain := TestChain{
		T:             suite.T(),
		ChainId:       chainId,
		Config:        *chaincfg,
		App:           mapp,
		CurrentHeader: header,
		TxConfig:      txConfig,
		Codec:         mapp.AppCodec(),
		Vals:          valSet,
		NextVals:      valSet,
		Signers:       signersByAddress,
		SenderPrivKey: senderPrivKey,
		SenderAccount: authacc,
	}

	ctx := chain.GetContext()
	mapp.AccountKeeper.SetAccount(ctx, authacc)

	_, err = mapp.Commit()
	require.NoError(t, err)

	suite.chain = chain
	suite.chains[chainId] = &chain

	err = suite.InitConsensusContract(resInit, pubKey.Address(), pubKey.Bytes(), privVal.PrivKey.Bytes(), valOperatorAddress)
	require.NoError(t, err)
}

func (suite *KeeperTestSuite) SetCurrentChain(chainId string) {
	chain := suite.GetChain(chainId)
	suite.Require().NotNil(chain)
	suite.chain = *chain
}

func (suite *KeeperTestSuite) InitConsensusContract(resInit *abci.ResponseInitChain, nodeAddress bytes.HexBytes, nodePubKey, nodePrivKey []byte, valOperatorAddress mcodec.AccAddressPrefixed) error {
	res, err := suite.App().Info(types.RequestInfo)
	if err != nil {
		return fmt.Errorf("error calling Info: %v", err)
	}
	// vals, err := cmttypes.PB2TM.ValidatorUpdates(resInit.Validators)
	// if err != nil {
	// 	return err
	// }
	// valOperatorAddress := sdk.AccAddress(vals[0].PubKey.Bytes())
	consensusParams := cmttypes.ConsensusParamsFromProto(*app.DefaultTestingConsensusParams)
	if resInit.ConsensusParams != nil {
		consensusParams = consensusParams.Update(resInit.ConsensusParams)
	}

	cfgNetwork := networkconfig.DefaultNetworkConfigConfig()

	currentState := suite.GetCurrentState(suite.chain.GetContext())

	peers := []string{}
	if !strings.Contains(currentState, "P2P") && !strings.Contains(currentState, "Level") {
		peers = []string{fmt.Sprintf(`%s@localhost:8090`, valOperatorAddress.String())}
	} else { // P2P, level0, etc
		peers = []string{fmt.Sprintf(`%s@/ip4/127.0.0.1/tcp/5001/p2p/12D3KooWMWpac4Qp74N2SNkcYfbZf2AWHz7cjv69EM5kejbXwBZF`, valOperatorAddress.String())}
	}
	err = networkserver.InitConsensusContract(
		suite.App(),
		suite.App().Logger(),
		suite.App().GetNetworkKeeper(),
		resInit.AppHash,
		&consensusParams,
		res.AppVersion,
		nodeAddress,
		nodePubKey,
		nodePrivKey,
		cfgNetwork.Id,
		peers,
	)
	if err != nil {
		return err
	}
	msg := []byte(`{"run":{"event": {"type": "start", "params": []}}}`)
	appA := suite.AppContext()
	_, err = suite.App().NetworkKeeper.ExecuteContract(appA.Context(), &types.MsgExecuteContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg,
	})
	suite.raftToLeader()
	return err
}

func (suite *KeeperTestSuite) Commit()                                               {}
func (suite *KeeperTestSuite) CommitNBlocks(chain *ibcgotesting.TestChain, n uint64) {}
func (suite *KeeperTestSuite) Coordinator() *ibcgotesting.Coordinator {
	return nil
}
func (suite *KeeperTestSuite) CommitNBlocks_(chain TestChain, n uint64) {
	for i := 0; i < int(n); i++ {
		_, err := suite.CommitBlock()
		suite.Require().NoError(err)
	}
}

func (s *KeeperTestSuite) GetRandomAccount() simulation.Account {
	pk := ed25519.GenPrivKey()
	privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

func (s *KeeperTestSuite) GetAccountFromMnemonic(mnemonic string) simulation.Account {
	s.Require().True(bip39.IsMnemonicValid(mnemonic))
	hdPath := hd.CreateHDPath(118, 0, 0).String()
	derivedPriv, err := hd.Secp256k1.Derive()(mnemonic, "", hdPath)
	s.Require().NoError(err)
	privKey := hd.Secp256k1.Generate()(derivedPriv)

	// privKey := secp256k1.GenPrivKeyFromSecret(pk.GetKey().Seed())
	pubKey := privKey.PubKey()
	address := sdk.AccAddress(pubKey.Address())
	account := simulation.Account{
		PrivKey: privKey,
		PubKey:  pubKey,
		Address: address,
	}
	return account
}

const bufSize = 1024 * 1024

func GrpcSetup(t *testing.T, mapp *app.App) *bufconn.Listener {
	goctx := context.Background()
	serverCtx := server.NewDefaultContext()
	clientCtx := client.Context{}.WithTxConfig(mapp.TxConfig()).WithChainID(mapp.ChainID())
	config, err := config.GetConfig(serverCtx.Viper)
	require.NoError(t, err)

	lis := bufconn.Listen(bufSize)
	grpcServer, err := NewGRPCServer(goctx, serverCtx, clientCtx, &config, mapp, nil)
	require.NoError(t, err)

	go func() {
		if err := grpcServer.Serve(lis); err != nil {
			log.Fatalf("Server exited with error: %v", err)
		}
	}()
	return lis
}

func (suite *KeeperTestSuite) GrpcClient(ctx context.Context, target string, mapp *app.App) (types.MsgClient, *grpc.ClientConn) {
	t := suite.T()
	lis := GrpcSetup(t, mapp)
	bufDialer := func(context.Context, string) (net.Conn, error) {
		return lis.Dial()
	}
	// target := "bufnet"
	conn, err := grpc.DialContext(ctx, target, grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
	if err != nil {
		t.Fatalf("Failed to dial bufnet: %v", err)
	}
	return types.NewMsgClient(conn), conn
}

func NewGRPCServer(
	ctx context.Context,
	svrCtx *server.Context,
	clientCtx client.Context,
	cfg *config.Config,
	app servertypes.Application,
	tmNode *node.Node,
) (*grpc.Server, error) {
	grpccfg := cfg.GRPC
	maxSendMsgSize := grpccfg.MaxSendMsgSize
	if maxSendMsgSize == 0 {
		maxSendMsgSize = sdkconfig.DefaultGRPCMaxSendMsgSize
	}

	maxRecvMsgSize := grpccfg.MaxRecvMsgSize
	if maxRecvMsgSize == 0 {
		maxRecvMsgSize = sdkconfig.DefaultGRPCMaxRecvMsgSize
	}

	grpcSrv := grpc.NewServer(
		grpc.ForceServerCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
		grpc.MaxSendMsgSize(maxSendMsgSize),
		grpc.MaxRecvMsgSize(maxRecvMsgSize),
	)

	_, err := keeper.RegisterGRPCServer(ctx, svrCtx, clientCtx, cfg, app, grpcSrv)
	if err != nil {
		return nil, fmt.Errorf("failed to register grpc server: %w", err)
	}
	return grpcSrv, nil
}

func (suite *KeeperTestSuite) FinalizeBlock(txs [][]byte) (*abci.ResponseFinalizeBlock, error) {
	for _, tx := range txs {
		msg := []byte(fmt.Sprintf(`{"run":{"event":{"type":"newTransaction","params":[{"key":"transaction", "value":"%s"}]}}}`, base64.StdEncoding.EncodeToString(tx)))
		_, err := suite.chain.App.NetworkKeeper.ExecuteContract(suite.chain.GetContext(), &types.MsgExecuteContract{
			Sender:   wasmxtypes.ROLE_CONSENSUS,
			Contract: wasmxtypes.ROLE_CONSENSUS,
			Msg:      msg,
		})
		if err != nil {
			return &abci.ResponseFinalizeBlock{TxResults: []*abci.ExecTxResult{{Code: 11, Log: err.Error()}}}, nil
		}
	}
	return suite.CommitBlock()
}

func (suite *KeeperTestSuite) CommitBlock() (*abci.ResponseFinalizeBlock, error) {
	lastInterval := suite.GetLastInterval(suite.chain.GetContext())
	currentState := suite.GetCurrentState(suite.chain.GetContext())
	blockDelay := suite.GetBlockDelay(suite.chain.GetContext())

	if lastInterval == "" {
		lastInterval = "0"
	}

	// if strings.Contains(currentState, "Tendermint-P2P") && strings.Contains(currentState, "Proposer") {
	// 	parts := strings.Split(currentState, ".")
	// 	currentState = strings.Join(parts[0:(len(parts)-1)], ".")
	// }

	// msg1 := []byte(`{"delay":"roundTimeout","state":"#Tendermint_0.initialized.prestart","intervalId":1}`)
	// msg1 := []byte(`{"delay":"heartbeatTimeout","state":"#RAFT-FULL-1.initialized.Leader.active","intervalId":2}`)
	msg1 := []byte(fmt.Sprintf(`{"delay":"%s","state":"%s","intervalId":%s}`, blockDelay, currentState, lastInterval))

	_, err := suite.chain.App.NetworkKeeper.ExecuteEntryPoint(suite.chain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg1,
	})
	if err != nil {
		return nil, err
	}

	lastBlock := suite.App().LastBlockHeight()
	res, err := suite.GetBlock(suite.chain.GetContext(), lastBlock)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (suite *KeeperTestSuite) GetBlockDelay(ctx sdk.Context) string {
	return suite.GetContextValue(ctx, types.BLOCK_DELAY, wasmxtypes.ROLE_CONSENSUS)
}

func (suite *KeeperTestSuite) GetCurrentState(ctx sdk.Context) string {
	msg := []byte(`{"getCurrentState":{}}`)
	resp, err := suite.chain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   wasmxtypes.ROLE_CONSENSUS,
		Contract: wasmxtypes.ROLE_CONSENSUS,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetContextValue(ctx sdk.Context, key string, addr string) string {
	msg := []byte(fmt.Sprintf(`{"getContextValue":{"key":"%s"}}`, key))
	resp, err := suite.chain.App.NetworkKeeper.QueryContract(ctx, &types.MsgQueryContract{
		Sender:   addr,
		Contract: addr,
		Msg:      msg,
	})
	suite.Require().NoError(err)
	var contractResp wasmxtypes.ContractResponse
	err = json.Unmarshal(resp.Data, &contractResp)
	suite.Require().NoError(err)
	return string(contractResp.Data)
}

func (suite *KeeperTestSuite) GetLastInterval(ctx sdk.Context) string {
	key := types.GetLastIntervalIdKey()
	return suite.GetContextValue(ctx, key, wasmxtypes.ROLE_CONSENSUS)
}

func (suite *KeeperTestSuite) GetBlock(ctx sdk.Context, height int64) (*abci.ResponseFinalizeBlock, error) {
	key := types.GetBlockKey(height)
	data := suite.GetContextValue(ctx, key, wasmxtypes.ROLE_STORAGE)
	if len(data) == 0 {
		return nil, fmt.Errorf("tx block (%d) not found", height)
	}
	var entry types.BlockEntry
	err := json.Unmarshal([]byte(data), &entry)
	if err != nil {
		return nil, err
	}
	var blockResultData abci.ResponseFinalizeBlock
	err = json.Unmarshal(entry.Result, &blockResultData)
	if err != nil {
		return nil, err
	}

	var header cmttypes.Header
	err = json.Unmarshal(entry.Header, &header)
	if err != nil {
		return nil, err
	}

	var lastCommit cmttypes.Commit
	err = json.Unmarshal(entry.LastCommit, &lastCommit)
	if err != nil {
		return nil, err
	}

	return &blockResultData, nil
}

func (suite *KeeperTestSuite) raftToLeader() {
	currentState := suite.GetCurrentState(suite.chain.GetContext())
	// get consensus version
	if strings.Contains(currentState, "#RAFT") && strings.Contains(currentState, "initialized.Follower") {
		msg1 := []byte(fmt.Sprintf(`{"delay":"electionTimeout","state":"%s","intervalId":%s}`, currentState, "1"))
		_, err := suite.chain.App.NetworkKeeper.ExecuteEntryPoint(suite.chain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
			Sender:   wasmxtypes.ROLE_CONSENSUS,
			Contract: wasmxtypes.ROLE_CONSENSUS,
			Msg:      msg1,
		})
		suite.Require().NoError(err)

		// raft p2p
		currentState = suite.GetCurrentState(suite.chain.GetContext())
		if strings.Contains(currentState, "Candidate") {
			lastInterval := suite.GetLastInterval(suite.chain.GetContext())
			msg1 = []byte(fmt.Sprintf(`{"delay":"electionTimeout","state":"%s","intervalId":%s}`, currentState, lastInterval))
			_, err = suite.chain.App.NetworkKeeper.ExecuteEntryPoint(suite.chain.GetContext(), wasmxtypes.ENTRY_POINT_TIMED, &types.MsgExecuteContract{
				Sender:   wasmxtypes.ROLE_CONSENSUS,
				Contract: wasmxtypes.ROLE_CONSENSUS,
				Msg:      msg1,
			})
			suite.Require().NoError(err)
		}
		currentState = suite.GetCurrentState(suite.chain.GetContext())
		suite.Require().Contains(currentState, "Leader")
	}
}

func (suite *KeeperTestSuite) commitBlock(res *abci.ResponseFinalizeBlock) {
	_, err := suite.chain.App.Commit()
	require.NoError(suite.T(), err)

	// set the last header to the current header
	// use nil trusted fields
	suite.chain.LastHeader = suite.chain.CurrentTMClientHeader()

	// val set changes returned from previous block get applied to the next validators
	// of this block. See tendermint spec for details.
	suite.chain.Vals = suite.chain.NextVals
	suite.chain.NextVals = ibcgotesting.ApplyValSetChanges(suite.T(), suite.chain.Vals, res.ValidatorUpdates)

	// increment the current header
	suite.chain.CurrentHeader = tmproto.Header{
		ChainID: suite.chain.ChainId,
		Height:  suite.chain.App.LastBlockHeight() + 1,
		AppHash: suite.chain.App.LastCommitID().Hash,
		// NOTE: the time is increased by the coordinator to maintain time synchrony amongst
		// chains.
		Time:               suite.chain.CurrentHeader.Time,
		ValidatorsHash:     suite.chain.Vals.Hash(),
		NextValidatorsHash: suite.chain.NextVals.Hash(),
		ProposerAddress:    suite.chain.CurrentHeader.ProposerAddress,
	}
}

// CreateTMClientHeader creates a TM header to update the TM client. Args are passed in to allow
// caller flexibility to use params that differ from the chain.
func (chain *TestChain) CreateTMClientHeader(chainID string, blockHeight int64, trustedHeight clienttypes.Height, timestamp time.Time, cmtValSet, nextVals, tmTrustedVals *cmttypes.ValidatorSet, signers map[string]cmttypes.PrivValidator) *ibctm.Header {
	var (
		valSet      *tmproto.ValidatorSet
		trustedVals *tmproto.ValidatorSet
	)
	require.NotNil(chain.T, cmtValSet)

	tmHeader := cmttypes.Header{
		Version:            tmprotoversion.Consensus{Block: cmtversion.BlockProtocol, App: 2},
		ChainID:            chainID,
		Height:             blockHeight,
		Time:               timestamp,
		LastBlockID:        MakeBlockID(make([]byte, tmhash.Size), 10_000, make([]byte, tmhash.Size)),
		LastCommitHash:     chain.App.LastCommitID().Hash,
		DataHash:           tmhash.Sum([]byte("data_hash")),
		ValidatorsHash:     cmtValSet.Hash(),
		NextValidatorsHash: nextVals.Hash(),
		ConsensusHash:      tmhash.Sum([]byte("consensus_hash")),
		AppHash:            chain.CurrentHeader.AppHash,
		LastResultsHash:    tmhash.Sum([]byte("last_results_hash")),
		EvidenceHash:       tmhash.Sum([]byte("evidence_hash")),
		ProposerAddress:    cmtValSet.Proposer.Address, //nolint:staticcheck
	}

	hhash := tmHeader.Hash()
	blockID := MakeBlockID(hhash, 3, tmhash.Sum([]byte("part_set")))
	voteSet := cmttypes.NewVoteSet(chainID, blockHeight, 1, tmproto.PrecommitType, cmtValSet)

	// MakeCommit expects a signer array in the same order as the validator array.
	// Thus we iterate over the ordered validator set and construct a signer array
	// from the signer map in the same order.
	var signerArr []cmttypes.PrivValidator   //nolint:prealloc // using prealloc here would be needlessly complex
	for _, v := range cmtValSet.Validators { //nolint:staticcheck // need to check for nil validator set
		signerArr = append(signerArr, signers[v.Address.String()])
	}

	extCommit, err := cmttypes.MakeExtCommit(blockID, blockHeight, 1, voteSet, signerArr, timestamp, false)
	require.NoError(chain.T, err)

	signedHeader := &tmproto.SignedHeader{
		Header: tmHeader.ToProto(),
		Commit: extCommit.ToCommit().ToProto(),
	}

	if cmtValSet != nil { //nolint:staticcheck
		valSet, err = cmtValSet.ToProto()
		require.NoError(chain.T, err)
	}

	if tmTrustedVals != nil {
		trustedVals, err = tmTrustedVals.ToProto()
		require.NoError(chain.T, err)
	}

	// The trusted fields may be nil. They may be filled before relaying messages to a client.
	// The relayer is responsible for querying client and injecting appropriate trusted fields.
	return &ibctm.Header{
		SignedHeader:      signedHeader,
		ValidatorSet:      valSet,
		TrustedHeight:     trustedHeight,
		TrustedValidators: trustedVals,
	}
}

func (chain *TestChain) CurrentTMClientHeader() *ibctm.Header {
	return chain.CreateTMClientHeader(
		chain.ChainId,
		chain.CurrentHeader.Height,
		clienttypes.Height{},
		chain.CurrentHeader.Time,
		chain.Vals,
		chain.NextVals,
		nil,
		chain.Signers,
	)
}

// MakeBlockID copied unimported test functions from cmttypes to use them here
func MakeBlockID(hash []byte, partSetSize uint32, partSetHash []byte) cmttypes.BlockID {
	return cmttypes.BlockID{
		Hash: hash,
		PartSetHeader: cmttypes.PartSetHeader{
			Total: partSetSize,
			Hash:  partSetHash,
		},
	}
}
